<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Sams_ara Jin" />


    
    


<meta name="description" content="不屈于他人之下，技术永远没有尽头，不断进步才能生存">
<meta property="og:type" content="website">
<meta property="og:title" content="huiHui&#39;s blogs">
<meta property="og:url" content="http://huilove.top/index.html">
<meta property="og:site_name" content="huiHui&#39;s blogs">
<meta property="og:description" content="不屈于他人之下，技术永远没有尽头，不断进步才能生存">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="huiHui&#39;s blogs">
<meta name="twitter:description" content="不屈于他人之下，技术永远没有尽头，不断进步才能生存">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="huiHui&#39;s blogs" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>huiHui&#39;s blogs</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Sams_ara Jin</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Java&amp;Python&amp;PHP&amp;Js&amp;C++全栈工程师</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/975715385@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/jingegebuguai" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa bilibili" href="http://bilibili.com" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS-ES6/">JS,ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS学习笔记/">JS学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java、linxu/">Java、linxu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LintCode/">LintCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lintcode/">Lintcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-angular/">js,angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://jingegebuguai.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于全栈</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Sams_ara Jin</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Sams_ara Jin</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Java&amp;Python&amp;PHP&amp;Js&amp;C++全栈工程师</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/975715385@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/jingegebuguai" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa bilibili" target="_blank" href="http://bilibili.com" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-爱奇艺面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/01/爱奇艺面试/" class="article-date">
      <time datetime="2018-03-01T03:03:35.299Z" itemprop="datePublished">2018-03-01</time>
</a>

 
    <a href="/2018/03/01/爱奇艺面试/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2018/03/01/爱奇艺面试/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近投了爱奇艺的java实习，本人是南京的一所双非院校，在途牛旅游网实习过一段时间。投完简历过了一天HR就和我约好时间远程面试，第二天等到下午四点一面开始。</p>
<p>1、一开始自我介绍，然后问我做过哪些项目，我只介绍了其中一个。<br>2、项目里的redis处理并发问题的根据是什么？<br>3、redis知道哪些数据类型？<br>4、紧接着开始问我spring的问题，解释IOC的原理，有哪些创建Bean的方式，xml配置和java配置是否可以同时存在，为什么？<br>5、aop的原理，什么是静态织入和动态织入？<br>6、restful api了解不，说说get，put，post，delete的区别？<br>7、你的项目里为什么都用post，有什么好处，处理json字符串的jar包是什么？<br>8、用过springboot吗？（没用过）springmvc的配置，有什么好处？servlet的原理，jdbc连接数据库。<br>9、mybatis的原理，如何实现？<br>10、数据库的事务隔离级别，什么是脏读，幻读？<br>11、数据库索引的原理是什么？B树和B+树有什么区别？什么是红黑树？有哪些索引？可不可以同时在一张表设置多个索引（n个）？索引的优缺点？一张性别表和一张学号表，哪个适合建索引？为什么？<br>12、数据库事务，spring事务如何实现？<br>13、看你项目里自己写过react和vue，接着开始问我前端，（很慌）。react和vue，angular的区别是什么？什么是虚拟DOM，vue的父子组件如何联系？什么是双向绑定，react如何实现双向绑定？会不会react redux，vuex？（这里不怎么说的清楚，很乱）<br>14、知道ES6吗，var和let区别，没有let，怎么处理var的问题（闭包和IIFE）？const？箭头函数？<br>15、样式会不会？什么是flex？为什么要用？如何实现左边固定，右边自适应？如何实现垂直水平居中？<br>16、还有一些问题记不大清了，庆幸没问算法。。。</p>
<p>过了一个小时二面的面试官打电话过来直接就说一面的面试官对我很满意，他就不问了，有点开心，然后开始询问我一些问题，最近的情况，能不能考虑转正的问题，可不可以全职？</p>
<p>过了十多分钟，还是二面那个面试官又打电话过来跟我介绍他们部门正在做的业务，让我提前把hadoop的知识学一学，说是要用到。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-NEC自适应布局" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/27/NEC自适应布局/" class="article-date">
      <time datetime="2018-01-27T12:00:00.000Z" itemprop="datePublished">2018-01-27</time>
</a>

 
    <a href="/2018/01/27/NEC自适应布局/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2018/01/27/NEC自适应布局/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/27/NEC自适应布局/">NEC定宽自适应布局</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>NEC是什么？<br>NEC是Nice Easy Css的简称，是网易（杭州）前端CSS开源项目代号，她为您提供漂亮简单的样式解决方案。</p>
<p>她包括了规范、框架、代码库、插件等内容，致力于为前端开发人员提供高效率高质量的前端页面开发解决方案，提高多人协作效率，也为非专业人员提供快速制作网页的解决方案。</p>
<ul>
<li>读规范，让你的代码更具智慧和美丽的方法</li>
<li>用框架，选择一份合适的HTML和CSS基础代码</li>
<li>找代码，在这里找到她，或给你启发，或她就是你的</li>
<li>装插件，帮助你快速有效的使用代码库</li>
</ul>
<p>今天特地学习了NEC自适应相关的布局，下面是主要的使用示例。</p>
<h3 id="两列左侧定款，右侧自适应布局"><a href="#两列左侧定款，右侧自适应布局" class="headerlink" title="两列左侧定款，右侧自适应布局"></a>两列左侧定款，右侧自适应布局</h3><pre><code>&lt;div class=&quot;g-bd1 f-cb&quot;&gt;
    &lt;div class=&quot;g-sd1&quot;&gt;
        &lt;p&gt;左侧定宽&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;g-mn1&quot;&gt;
        &lt;div class=&quot;g-mn1c&quot;&gt;
            &lt;p&gt;右侧自适应&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
    .g-bd1{margin:0 0 10px;}
    .g-sd1{position:relative;float:left;width:190px;margin-right:-190px;}
    .g-mn1{float:right;width:100%;}
    .g-mn1c{margin-left:200px;}
    p{height: 150px;padding: 10px;color: #fff;background: orange;}
&lt;/style&gt;
</code></pre><p><img src="http://chuantu.biz/t6/216/1517034723x-1404758503.png" alt=""></p>
<p>其中左侧定宽，设置相对定位，左浮动脱离文档流，右移定宽的负值；</p>
<p>右侧设为右浮动，宽为100%，右侧margin-left设为左侧定宽+隔开距离；</p>
<p>注意：这里负边距如果低于左侧宽度，将会无法满足右侧100%宽度要求，需要自己动手实验哈。</p>
<h3 id="两列右侧定宽，左侧自适应布局"><a href="#两列右侧定宽，左侧自适应布局" class="headerlink" title="两列右侧定宽，左侧自适应布局"></a>两列右侧定宽，左侧自适应布局</h3><pre><code>&lt;div class=&quot;zell-dm2 g-bd2 f-cb&quot;&gt;
    &lt;div class=&quot;g-mn2&quot;&gt;
        &lt;div class=&quot;g-mn2c&quot;&gt;
            &lt;p&gt;
                我是左侧
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;g-sd2&quot;&gt;
        &lt;p&gt;
            我是右侧
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
.g-sd2{float: right;position: relative;width:240px;margin-left:-240px;}
.g-mn2 {float: left;width:100%;}
.g-mn2c {margin-right: 280px;}
.zell-dm2 p{background: pink;height:300px;padding:5px;}
&lt;/style&gt;
</code></pre><p><img src="http://i4.bvimg.com/591295/4a6d2f7cdd112c11.png" alt=""></p>
<p>和上一个思路相同。</p>
<h3 id="三列左侧自适应布局"><a href="#三列左侧自适应布局" class="headerlink" title="三列左侧自适应布局"></a>三列左侧自适应布局</h3><pre><code>&lt;div id=&quot;demo&quot;&gt;
    &lt;div class=&quot;g-bd4 f-cb&quot;&gt;
        &lt;div class=&quot;g-sd41&quot;&gt;
            &lt;p&gt;右侧定宽1&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;g-sd42&quot;&gt;
            &lt;p&gt;右侧定宽2&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;g-mn4&quot;&gt;
            &lt;div class=&quot;g-mn4c&quot;&gt;
                &lt;p&gt;左侧自适应&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
    #demo{
        width:980px;margin:auto;
        margin-top: 45px;
    }
    .g-bd4{
        border:1px solid black;
    }
    .g-sd41,.g-sd42{
        position: relative;float: right;width:230px;
    }
    .g-sd42{
        width:190px;margin-right: 10px;
    }
    .g-mn4{
        float: left;width:100%;margin-right: -430px;
    }
    .g-mn4c{
        margin-right:440px;
    }
    .g-bd4 p{
        padding:5px;background-color: orange;
        height:140px;
    }
&lt;/style&gt;
</code></pre><p><img src="http://i4.bvimg.com/591295/0bf31a28acc6013e.png" alt=""></p>
<p>原理依然使用负边距消除溢出。</p>
<h3 id="三列左侧右侧定宽，中间自适应"><a href="#三列左侧右侧定宽，中间自适应" class="headerlink" title="三列左侧右侧定宽，中间自适应"></a>三列左侧右侧定宽，中间自适应</h3><pre><code>&lt;div class=&quot;g-bd5 f-cb&quot;&gt;
    &lt;div class=&quot;g-sd51&quot;&gt;
        &lt;p&gt;
            左侧定宽
        &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;g-mn5&quot;&gt;
        &lt;div class=&quot;g-mn5c&quot;&gt;
            &lt;p&gt;
                中间自适应
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;g-sd52&quot;&gt;
        &lt;p&gt;
            右侧定宽
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
    .g-bd5 {
        margin: 45px 0 0 0;
    }
    .g-sd51,.g-sd52{
        position: relative;width:240px;
        margin: 0 -240px 0 0;
        float: left;
    }
    .g-sd52{
        float: right;
        margin:0 0 0 -240px;
    }
    .g-mn5 {
        float: left;
        width:100%;
    }
    .g-mn5c{
        margin:0 250px 0 250px;
    }
    .g-bd5 p{
        height:120px;
        background-color:pink;
        padding:5px;
    }
&lt;/style&gt;
</code></pre><p><img src="http://i4.bvimg.com/591295/65647995e909b08a.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS学习笔记/">JS学习笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/19/git常用命令/" class="article-date">
      <time datetime="2017-12-19T10:39:00.000Z" itemprop="datePublished">2017-12-19</time>
</a>

 
    <a href="/2017/12/19/git常用命令/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/12/19/git常用命令/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/19/git常用命令/">工作中常用的Git命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p>学生时期很早就开始玩git了，但是一直都是那几个命令玩来玩去，一直都没有真正的理解学会使用他们。</p>
<p>直到实习后，我们所写的代码都是需要提交到公司仓库，这正好弥补我之前的不足，我将在公司中常用的git命令总结如下。</p>
<h5 id="git-init——初始化本地git仓库，建立新仓库"><a href="#git-init——初始化本地git仓库，建立新仓库" class="headerlink" title="git init——初始化本地git仓库，建立新仓库"></a>git init——初始化本地git仓库，建立新仓库</h5><h5 id="git-clone——克隆远程仓库"><a href="#git-clone——克隆远程仓库" class="headerlink" title="git clone——克隆远程仓库"></a>git clone——克隆远程仓库</h5><h5 id="git-status——查看当前状态，看是否修改，哪些文件发生了变动"><a href="#git-status——查看当前状态，看是否修改，哪些文件发生了变动" class="headerlink" title="git status——查看当前状态，看是否修改，哪些文件发生了变动"></a>git status——查看当前状态，看是否修改，哪些文件发生了变动</h5><h5 id="git-add-–all——添加所有变动的文件至index"><a href="#git-add-–all——添加所有变动的文件至index" class="headerlink" title="git add –all——添加所有变动的文件至index"></a>git add –all——添加所有变动的文件至index</h5><h5 id="git-commit-m-“-“——提交"><a href="#git-commit-m-“-“——提交" class="headerlink" title="git commit -m “*“——提交"></a>git commit -m “<em>*</em>“——提交</h5><h5 id="git-push-origin-master-或分支名-——将当前分支push到远程分支"><a href="#git-push-origin-master-或分支名-——将当前分支push到远程分支" class="headerlink" title="git push origin master(或分支名)——将当前分支push到远程分支"></a>git push origin master(或分支名)——将当前分支push到远程分支</h5><h5 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h5><p>获取远程分支，并merge到本地分支，有时候一个仓库并不是你一个提交，经常会多人提交，所以在每次提交之前需要pull一下，更新自己的本地分支数据。</p>
<h5 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h5><p>获取所有远程分支（不更新本地分支，另需merge）,需要严格与git pull区分开来。</p>
<h5 id="git-branch——显示所有本地分支"><a href="#git-branch——显示所有本地分支" class="headerlink" title="git branch——显示所有本地分支"></a>git branch——显示所有本地分支</h5><h5 id="git-branch-a-——显示所有分支"><a href="#git-branch-a-——显示所有分支" class="headerlink" title="git branch -a ——显示所有分支"></a>git branch -a ——显示所有分支</h5><h5 id="git-branch-r-——显示所有原创分支"><a href="#git-branch-r-——显示所有原创分支" class="headerlink" title="git branch -r ——显示所有原创分支"></a>git branch -r ——显示所有原创分支</h5><h5 id="git-checkout-branch分支名-——创建分支"><a href="#git-checkout-branch分支名-——创建分支" class="headerlink" title="git checkout (branch分支名)——创建分支"></a>git checkout (branch分支名)——创建分支</h5><h5 id="git-diff——显示所有未添加至index的变更"><a href="#git-diff——显示所有未添加至index的变更" class="headerlink" title="git diff——显示所有未添加至index的变更"></a>git diff——显示所有未添加至index的变更</h5><h5 id="git-log——显示提交日志"><a href="#git-log——显示提交日志" class="headerlink" title="git log——显示提交日志"></a>git log——显示提交日志</h5>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java Spring使用restTemplate调用其他接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/19/Java Spring使用restTemplate调用其他接口/" class="article-date">
      <time datetime="2017-12-19T10:33:00.000Z" itemprop="datePublished">2017-12-19</time>
</a>

 
    <a href="/2017/12/19/Java Spring使用restTemplate调用其他接口/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/12/19/Java Spring使用restTemplate调用其他接口/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/19/Java Spring使用restTemplate调用其他接口/">Java Spring使用restTemplate实现调用其他接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>公司里经常会碰到不同项目之间互相调用接口的情况，一般而言接口都是提供给前端调用，在查询资料后我发现Spring中有一种很便利的方法可以访问接口。</p>
<h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷<font style="color:red">访问远程Http服务的方法</font>，能够大大提高客户端的编写效率。</p>
<p>调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。<br>ClientHttpRequestFactory接口主要提供了两种实现方式</p>
<ul>
<li>一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接。</li>
<li><p>一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。</p>
<p>RestTemplate默认是使用SimpleClientHttpRequestFactory，内部是调用jdk的HttpConnection，默认超时为-1</p>
</li>
</ul>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h4 id="基于jdk的spring的RestTemplate"><a href="#基于jdk的spring的RestTemplate" class="headerlink" title="基于jdk的spring的RestTemplate"></a>基于jdk的spring的RestTemplate</h4><pre><code>//我不得不打注释，否则下面代码或被屏蔽，无奈！
&lt;!-- &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; --&gt;
&lt;beans  xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;
    default-autowire=&quot;byName&quot; default-lazy-init=&quot;true&quot;&gt;

    &lt;!--方式一、使用jdk的实现--&gt;
    &lt;bean id=&quot;ky.requestFactory&quot; class=&quot;org.springframework.http.client.SimpleClientHttpRequestFactory&quot;&gt;
        &lt;property name=&quot;readTimeout&quot; value=&quot;10000&quot;/&gt;
        &lt;property name=&quot;connectTimeout&quot; value=&quot;5000&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;simpleRestTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;&gt;
        &lt;constructor-arg ref=&quot;ky.requestFactory&quot;/&gt;
        &lt;property name=&quot;messageConverters&quot;&gt;
            &lt;list&gt;
                &lt;bean class=&quot;org.springframework.http.converter.FormHttpMessageConverter&quot;/&gt;
                &lt;bean class=&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;/&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;
                &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                    &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                        &lt;list&gt;
                            &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><h4 id="HttpClient连接池方法"><a href="#HttpClient连接池方法" class="headerlink" title="HttpClient连接池方法"></a>HttpClient连接池方法</h4><pre><code>&lt;!--使用httpclient的实现，带连接池--&gt;
&lt;!--在httpclient4.3版本后才有--&gt;
&lt;bean id=&quot;httpClientBuilder&quot; class=&quot;org.apache.http.impl.client.HttpClientBuilder&quot; factory-method=&quot;create&quot;&gt;
    &lt;property name=&quot;connectionManager&quot;&gt;
        &lt;bean class=&quot;org.apache.http.impl.conn.PoolingHttpClientConnectionManager&quot;&gt;
            &lt;!--整个连接池的并发--&gt;
            &lt;property name=&quot;maxTotal&quot; value=&quot;50&quot;/&gt;
            &lt;!--每个主机的并发--&gt;
            &lt;property name=&quot;defaultMaxPerRoute&quot; value=&quot;50&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;!--开启重试--&gt;
    &lt;property name=&quot;retryHandler&quot;&gt;
        &lt;bean class=&quot;org.apache.http.impl.client.DefaultHttpRequestRetryHandler&quot;&gt;
            &lt;constructor-arg value=&quot;2&quot;/&gt;
            &lt;constructor-arg value=&quot;true&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;defaultHeaders&quot;&gt;
        &lt;list&gt;
            &lt;bean class=&quot;org.apache.http.message.BasicHeader&quot;&gt;
            &lt;constructor-arg value=&quot;Content-Type&quot;/&gt;
            &lt;constructor-arg value=&quot;text/html;charset=UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.apache.http.message.BasicHeader&quot;&gt;
            &lt;constructor-arg value=&quot;Accept-Encoding&quot;/&gt;
            &lt;constructor-arg value=&quot;gzip,deflate&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.apache.http.message.BasicHeader&quot;&gt;
            &lt;constructor-arg value=&quot;Accept-Language&quot;/&gt;
            &lt;constructor-arg value=&quot;zh-CN&quot;/&gt;
        &lt;/bean&gt;
    &lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;httpClient&quot; factory-bean=&quot;httpClientBuilder&quot; factory-method=&quot;build&quot;/&gt;

&lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
        &lt;list value-type=&quot;org.springframework.http.converter.HttpMessageConverter&quot;&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
            &lt;bean class=&quot;org.springframework.http.converter.ResourceHttpMessageConverter&quot;/&gt;
            &lt;bean class=&quot;org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter&quot;/&gt;
            &lt;bean class=&quot;org.springframework.http.converter.FormHttpMessageConverter&quot;/&gt;
            &lt;bean class=&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;requestFactory&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.client.HttpComponentsClientHttpRequestFactory&quot;&gt;
            &lt;constructor-arg ref=&quot;httpClient&quot;/&gt;
            &lt;!--连接时间(毫秒)--&gt;
            &lt;property name=&quot;connectTimeout&quot; value=&quot;20000&quot;/&gt;
            &lt;!--读取时间(毫秒)--&gt;
            &lt;property name=&quot;readTimeout&quot; value=&quot;20000&quot;/&gt;
        &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="对调POST接口"><a href="#对调POST接口" class="headerlink" title="对调POST接口"></a>对调POST接口</h3><pre><code>public &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)
        throws RestClientException

public &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)
            throws RestClientException

public &lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException
</code></pre><p>上面三个是常用的调用POST接口的方法</p>
<ul>
<li>url：请求的url接口</li>
<li>request：请求参数，通常为json格式</li>
<li>responseType：响应的类型</li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code>//设置请求头
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.parseMediaType(&quot;application/json;charset=UTF-8&quot;));
headers.add(&quot;Accept&quot;, MediaType.APPLICATION_JSON.toString());

MultiValueMap&lt;String, String&gt; postParameters = new LinkedMultiValueMap&lt;String, String&gt;();
postParameters.add(&quot;owner&quot;, &quot;11&quot;);
postParameters.add(&quot;subdomain&quot;, &quot;aoa&quot;);
postParameters.add(&quot;comment&quot;, &quot;&quot;);

//对post请求参数进行封装
String bodyData = new String(Base64Util.encodeData(JSON.toJSONString(postParameters)).getBytes(&quot;UTF-8&quot;), &quot;UTF-8&quot;);

//表示一个HTTP请求或响应实体，由标题和正文组成。
HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity  = new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(bodyData, headers);

ParseResultVo exchange = null;
try {
    exchange = restTemplate.postForObject(&quot;http://l-dnsutil1.ops.beta.cn6.qunar.com:10085/v1/cnames/tts.piao&quot;,  requestEntity, ParseResultVo.class);
    logger.info(exchange.toString());
} catch (RestClientException e) {
    logger.info(&quot;。。。。&quot;);
</code></pre><p>}</p>
<p>一般在spring中，我们将url设置为属性文件，通过注解@Value(value=”@properties.url”)获取。</p>
<h3 id="对调GET接口"><a href="#对调GET接口" class="headerlink" title="对调GET接口"></a>对调GET接口</h3><pre><code>public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... urlVariables) throws RestClientException 

public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables) throws RestClientException

public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException
</code></pre><h4 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h4><pre><code>String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class,&quot;42&quot;, &quot;21&quot;);

String message = restTemplate.getForObject(&quot;http://localhost:8080/yongbarservice/appstore/appgoods/restTemplate?name=zhaoshijie&amp;id=80&quot;, String.class );
</code></pre><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>返回数据格式如下：</p>
<pre><code>{
&quot;ret&quot;: 0,
&quot;msg&quot;: &quot;success&quot;,
&quot;bankQuota&quot;: [
    {
        &quot;frontBankCode&quot;: &quot;4033&quot;,
        &quot;bankName&quot;: &quot;工行&quot;,
        &quot;singleLimitAmount&quot;: &quot;xx万&quot;,
        &quot;dailyLimitAmount&quot;: &quot;xx万&quot;,
        &quot;monthlyLimitAmount&quot;: &quot;无限额&quot;,
        &quot;pcQuota&quot;: &quot;单笔xx万&quot;,
        &quot;orderNo&quot;: null
    },
    {
        &quot;frontBankCode&quot;: &quot;4011&quot;,
        &quot;bankName&quot;: &quot;建行&quot;,
        &quot;singleLimitAmount&quot;: &quot;yy万&quot;,
        &quot;dailyLimitAmount&quot;: &quot;yy万&quot;,
        &quot;monthlyLimitAmount&quot;: &quot;无限额&quot;,
        &quot;pcQuota&quot;: &quot;单笔yy万&quot;,
        &quot;orderNo&quot;: null
    }
}
</code></pre><p>请求代码：</p>
<pre><code>@RequestMapping(&quot;queryBankLimit&quot;)
@ResponseBody
public  List&lt;BankLimitVo&gt; queryBankLimit(){
    RestTemplate restTemplate = new RestTemplate();
    BankLimitResponse limitResponse = restTemplate.getForObject
            (&quot;https://dubai.com/xx/query?sp=12&amp;from=0.0.0&quot;,
                  BankLimitResponse.class);
    List&lt;BankLimitVo&gt; result = limitResponse.getBankQuota();
    return result;
}
</code></pre><p>响应类：</p>
<pre><code>public class BankLimitResponse {
private int ret;
private String msg;
private List&lt;BankLimitVo&gt; bankQuota;
.....getter和setter方法
}
</code></pre><p>vo类</p>
<pre><code>public class BankLimitVo {
String frontBankCode;
String bankName;
String singleLimitAmount;
String dailyLimitAmount;
String monthlyLimitAmount;
 .... getter和setter方法
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java读写Properties属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/06/Java读写Properties属性/" class="article-date">
      <time datetime="2017-11-06T10:33:00.000Z" itemprop="datePublished">2017-11-06</time>
</a>

 
    <a href="/2017/11/06/Java读写Properties属性/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/06/Java读写Properties属性/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/06/Java读写Properties属性/">Java读写Properties属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties属性文件在JAVA应用程序中是经常可以看得见的，也是特别重要的一类文件。它用来配置应用程序的一些信息，不过这些信息一般都是比较少的数据，没有必要使用数据库文件来保存，而使用一般的文本文件来保存，如果是通过File直接保存的话，可能在存储和读取上都不是很方便，但如果保存为Properties文件就不一样了，属性文件都有键值对应的，在JAVA的包中，有提供专门的操作属性文件的类。这个类就是 java.uitl.Properties类，由于Properties类是一个集合类，所以，Properties会将属性以集合的方式读写。 </p>
<p>Properties类继承字Hashtable类，采用键值对应的存储方式.</p>
<h3 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h3><pre><code>public void load(InputStream isStream) throws IOExpection {}
public void store(OutputStream out, String comments) throws IOExpection {}
</code></pre><h3 id="创建一个course-properties文件"><a href="#创建一个course-properties文件" class="headerlink" title="创建一个course.properties文件"></a>创建一个course.properties文件</h3><pre><code>ftp.server.ip=10.160.105.135
ftp.user=ftpuser
ftp.pass=123456
ftp.server.http.prefix=http://image.huihui.com/

alipay.callback.url=http://www.huihui.com/order/alipay_callback.do

password.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF.,
</code></pre><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><pre><code>Properties prop = new Properties();//属性集合对象    
FileInputStream fis = new FileInputStream(&quot;course.properties&quot;);//属性文件流    
prop.load(fis);//将属性文件流装载到Properties对象中  
</code></pre><p>上面代码是读取文件最基本的方式，但是如果我们在ssm框架中使用该怎么写呢？</p>
<pre><code>props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(&quot;course.properties&quot;),&quot;UTF-8&quot;));
</code></pre><p>Tools.class.getClassLoader().getResourceAsStream(file); </p>
<p>首先，调用对象的getClass()方法是获得对象当前的类类型，这部分数据存在方法区中，而后在类类型上调用getClassLoader()方法是得到当前类型的类加载器，在Java中所有的类都是通过加载器加载到虚拟机中的，而且类加载器之间存在父子关系，就是子知道父，父不知道子，这样不同的子加载的类型之间是无法访问的（虽然它们都被放在方法区中），所以在这里通过当前类的加载器来加载资源也就是保证是和类类型同一个加载器加载的。<br>最后调用了类加载器的getResourceAsStream()方法来加载文件资源</p>
<p>ClassLoader.getResourceAsStream() 与 Class.getResourceAsStream()的区别</p>
<pre><code>Class.getResourceAsStream() 会指定要加载的资源路径与当前类所在包的路径一致。
</code></pre><p> 例如你写了一个MyTest类在包com.test.mycode 下，那么MyTest.class.getResourceAsStream(“name”) 会在com.test.mycode包下查找相应的资源。    </p>
<h3 id="读取键值方法"><a href="#读取键值方法" class="headerlink" title="读取键值方法"></a>读取键值方法</h3><ul>
<li>Properties类提供了getProperty(String key)方法用来通过键名读取键值，</li>
<li>当key在属性集合中找不到时又想为key在程序中赋予一个值时可以使用public String getProperty(String key, String defaultValue)方法，这个方法的意思就是用指定的键在属性列表中搜索属性。如果在属性列表中未找到该键，则接着递归检查默认属性列表及其默认值。如果未找到属性，则此方法返回默认值变量： </li>
</ul>
<h3 id="设置（写）属性"><a href="#设置（写）属性" class="headerlink" title="设置（写）属性"></a>设置（写）属性</h3><p>setProperty(String key, String value)，这个方法就是当属性集合中存在指定的key时，就修改这个key的值，如果不存在，就新建一个key，同样是通过键值关系保存的，但值得注意的是，Properties类继承自Hashtable，所以也可以用Hashtable的put和putAll方法保存，但强烈反对使用这两个方法，因为它们允许调用方插入其键或值不是 Strings 的项。相反，应该使用 setProperty 方法。</p>
<pre><code>//修改sitename的属性值 
prop.setProperty(&quot;sitename&quot;, &quot;Boxcode&quot;); 
//添加一个新的属性studio 
prop.setProperty(&quot;studio&quot;, &quot;Boxcode Studio&quot;); 
//文件输出流 
FileOutputStream fos = new FileOutputStream(&quot;prop.properties&quot;); 
//将Properties集合保存到流中 
prop.store(fos, &quot;Copyright (c) Boxcode Studio&quot;); 
fos.close();//关闭流 
</code></pre><p>我们一般使用的多为读取属性，写了解便可。</p>
<h3 id="读接口示例"><a href="#读接口示例" class="headerlink" title="读接口示例"></a>读接口示例</h3><pre><code>public class PropertiesUtil {

    private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class);

    private static Properties props;

    static {
        String fileName = &quot;course.properties&quot;;
        props = new Properties();
        try {
            props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader()
                .getResourceAsStream(fileName),&quot;UTF-8&quot;));
        } catch (IOException e) {
            logger.error(&quot;配置文件读取异常&quot;,e);
        }
    }

    public static String getProperty(String key){
        String value = props.getProperty(key.trim());
        if(StringUtils.isBlank(value)){
            return null;
        }
        return value.trim();
    }

    public static String getProperty(String key,String defaultValue){

        String value = props.getProperty(key.trim());
        if(StringUtils.isBlank(value)){
            value = defaultValue;
        }
        return value.trim();
    }

}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java MD5加密" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/06/Java MD5加密/" class="article-date">
      <time datetime="2017-11-06T06:33:00.000Z" itemprop="datePublished">2017-11-06</time>
</a>

 
    <a href="/2017/11/06/Java MD5加密/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/06/Java MD5加密/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/06/Java MD5加密/">Java MD5加密</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>从PHP到Python，再到做Java Web，每次使用的加密解密方法都不尽相同，TP框架依然使用的是MD5，Laravel使用的是自带的辅助函数encrypt加密，decript揭秘。Python django使用的也是自带cript，一般也会引入make_password和check_password模块，Java都是自己写接口，很累，包括MD5，BASE64，DES，RSA等。</p>
<h3 id="何为MD5"><a href="#何为MD5" class="headerlink" title="何为MD5?"></a>何为MD5?</h3><p>MD5算法将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。这就相当于这个文件的指纹，如果有任何人修改了文件内容，或下载文件由于网络问题不完整，则生成的md5值也会发生变化。</p>
<p>MD5算法本质是一个哈希算法，因此MD5值就是一个哈希值。</p>
<ul>
<li>对于同样的文件，计算出的MD5值永远是一样的。MD5算法中没有任何随机数或不确定因素。</li>
<li>MD5算法是公开的。因而我们可以找到很多个MD5生成器，但背后的算法是一样的。</li>
<li>我们可以认为世界上的文件是无限的，而得到的MD5值永远是一个128位二进制数。因此是一个无穷序列到一个有限序列的映射。进而可以得知，MD5算法是不可逆的，也就是说，我们不能用一个MD5值来推算出源文件的内容。</li>
<li>从无穷序列到有限序列的映射这点又可以推断出，MD5算法可能产生冲突(这也是所有哈希函数都会遇到的问题)。即两个不同的文件，可能会产生一样的MD5值。</li>
</ul>
<h3 id="编写MD5加密实例"><a href="#编写MD5加密实例" class="headerlink" title="编写MD5加密实例"></a>编写MD5加密实例</h3><h4 id="String-getBytes"><a href="#String-getBytes" class="headerlink" title="String.getBytes()"></a>String.getBytes()</h4><p>Java中，getBytes()方法得到一个操作系统默认的编码格式字节数组。</p>
<h4 id="String-getBytes-String-decode"><a href="#String-getBytes-String-decode" class="headerlink" title="String.getBytes(String decode)"></a>String.getBytes(String decode)</h4><p>该方法会根据指定的decode编码返回某字节在该编码下的byte数组</p>
<ul>
<li>byte[] b_gbk = “中”.getBytes(“GBK”); </li>
<li>byte[] b_utf8 = “中”.getBytes(“UTF-8”); </li>
<li>byte[] b_iso88591 = “中”.getBytes(“ISO8859-1”);<br>title: Java MD5加密<br>author: 惠惠<br>tags:<ul>
<li>Java<br>categories:</li>
<li>计算机<br>date: 2017-11-06 14:14:00</li>
</ul>
</li>
</ul>
<hr>
<p>将分别返回“中”这个汉字在GBK、UTF-8和ISO8859-1编码下的byte数组表示，此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1。</p>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><h5 id="创建md5对象"><a href="#创建md5对象" class="headerlink" title="创建md5对象"></a>创建md5对象</h5><pre><code>MessageDigest md5 = MessageDigest.getInstance(&quot;md5&quot;); 
</code></pre><h5 id="进行加密操作"><a href="#进行加密操作" class="headerlink" title="进行加密操作"></a>进行加密操作</h5><pre><code>byte[] cipherData = md5.digest(plainText.getBytes());  
</code></pre><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><pre><code>public class MD5Util {

    private static String MD5Encode(String origin, String charsetName) {
        String resultString = null;
        try {
            resultString = new String(origin);
            MessageDigest md5 = MessageDigest.getInstance(&quot;md5&quot;);
            if(charsetName==null || &quot;&quot;.equals(charsetName))
                 resultString = byteArrayToHexString(md.digest(resultString.getBytes()));
            else
                resultString = byteArrayToHexString(md.digest(resultString.getBytes(charsetname)));
        } catch (Exception exception) {
        }
        return resultString.toUpperCase();
    }

    private static String byteArrayToHexString(byte b[]) {
       StringBuffer resultSb = new StringBuffer();
        for (int i = 0; i &lt; b.length; i++)
            resultSb.append(byteToHexString(b[i]));

        return resultSb.toString();
    }    

    //在原始字符串前加上一串字符目的是增强安全，防止解密后获得原始密码
    public static String MD5EncodeUtf8(String origin) {
        origin = origin + PropertiesUtil.getProperty(&quot;password.salt&quot;, &quot;&quot;);
        return MD5Encode(origin, &quot;utf-8&quot;);
    }

}
</code></pre><p>上述示例中的MD5EncodeUtf8函数使用了Properties属性加载类，具体实现方法下一篇文章叙述。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Spring整合Java Web Token" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/06/Spring整合Java Web Token/" class="article-date">
      <time datetime="2017-11-06T04:33:00.000Z" itemprop="datePublished">2017-11-06</time>
</a>

 
    <a href="/2017/11/06/Spring整合Java Web Token/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/06/Spring整合Java Web Token/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/06/Spring整合Java Web Token/">Spring 整合Json Web Token</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Java-Web-Token"><a href="#Java-Web-Token" class="headerlink" title="Java Web Token"></a>Java Web Token</h2><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3><p>一个JWT实际上就是一个字符串，它由三部分组成，<span style="color:red">头部、载荷与签名。</span></p>
<h3 id="荷载"><a href="#荷载" class="headerlink" title="荷载"></a>荷载</h3><pre><code>{
&quot;iss&quot;: &quot;John Wu JWT&quot;,
&quot;iat&quot;: 1441593502,
&quot;exp&quot;: 1441594722,
&quot;aud&quot;: &quot;www.example.com&quot;,
&quot;sub&quot;: &quot;jrocket@example.com&quot;,
&quot;from_user&quot;: &quot;B&quot;,
&quot;target_user&quot;: &quot;A&quot;
}
</code></pre><p>这里面的前五个字段都是由JWT的标准所定义的。</p>
<ul>
<li>iss: 该JWT的签发者</li>
<li>sub: 该JWT所面向的用户</li>
<li>aud: 接收该JWT的一方</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li>iat(issued at): 在什么时候签发的</li>
</ul>
<p>这些定义都可以在标准中找到。</p>
<p>将上面的JSON对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）。</p>
<pre><code>eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9
</code></pre><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>JWT还需要一个头部，头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p>
<pre><code>{
</code></pre><p>  “typ”: “JWT”,<br>  “alg”: “HS256”<br>    }</p>
<p>在这里，我们说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法。（算法根据实际情况而变）</p>
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
</code></pre><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>签名就是将荷载和头部编码用.号连接在一起就形成了</p>
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0
</code></pre><p>我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用mystar作为密钥的话，那么就可以得到我们加密后的内容</p>
<pre><code>rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
</code></pre><p>最后将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的JWT</p>
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
</code></pre><h4 id="签名的目的"><a href="#签名的目的" class="headerlink" title="签名的目的"></a>签名的目的</h4><p>最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。</p>
<p>所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。</p>
<p>服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用alg字段指明了我们的加密算法了。</p>
<p>如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。</p>
<p>我们可以看到，JWT适合用于向Web应用传递一些非敏感信息。例如在上面提到的完成加好友的操作，还有诸如下订单的操作等等。</p>
<p>其实JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。</p>
<h2 id="Spring使用JWT"><a href="#Spring使用JWT" class="headerlink" title="Spring使用JWT"></a>Spring使用JWT</h2><h3 id="Maven配置方式"><a href="#Maven配置方式" class="headerlink" title="Maven配置方式"></a>Maven配置方式</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.auth0&lt;/groupId&gt;
    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="JWT算法-了解"><a href="#JWT算法-了解" class="headerlink" title="JWT算法(了解)"></a>JWT算法(了解)</h3><table>
<thead>
<tr>
<th>JWS</th>
<th style="text-align:center">算法</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>HS256</td>
<td style="text-align:center">HMAC256</td>
<td>HMAC with SHA-256</td>
</tr>
<tr>
<td>HS384</td>
<td style="text-align:center">HMAC384</td>
<td>HMAC with SHA-384</td>
</tr>
<tr>
<td>HS512</td>
<td style="text-align:center">HMAC512</td>
<td>HMAC with SHA-512</td>
</tr>
<tr>
<td>RS256</td>
<td style="text-align:center">RSA256</td>
<td>RSASSA-PKCS1-v1_5 with SHA-256</td>
</tr>
<tr>
<td>RS384</td>
<td style="text-align:center">RSA384</td>
<td>RSASSA-PKCS1-v1_5 with SHA-384</td>
</tr>
<tr>
<td>RS512</td>
<td style="text-align:center">RSA512</td>
<td>RSASSA-PKCS1-v1_5 with SHA-512</td>
</tr>
<tr>
<td>ES256</td>
<td style="text-align:center">ECDSA256</td>
<td>ECDSA with curve P-256 and SHA-256</td>
</tr>
<tr>
<td>ES384</td>
<td style="text-align:center">ECDSA384</td>
<td>ECDSA with curve P-384 and SHA-384</td>
</tr>
<tr>
<td>ES512</td>
<td style="text-align:center">ECDSA512</td>
<td>ECDSA with curve P-521 and SHA-512</td>
</tr>
</tbody>
</table>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><p>算法定义了一个令牌是如何被签名和验证的。它可以用HMAC算法的原始值来实例化，也可以在RSA和ECDSA算法的情况下对密钥对或密钥提供程序进行实例化。创建后，该实例可用于令牌签名和验证操作。</p>
<p>在使用RSA或ECDSA算法时，只需要签署JWTs，就可以通过传递null值来避免指定公钥。当您需要验证JWTs时，也可以使用私钥进行操作</p>
<p>使用静态的字符密文或者key来获取算法器:</p>
<pre><code>//HMAC
Algorithm algorithmHS = Algorithm.HMAC256(&quot;secret&quot;);

//RSA
RSAPublicKey publicKey = //Get the key instance
RSAPrivateKey privateKey = //Get the key instance
Algorithm algorithmRS = Algorithm.RSA256(publicKey, privateKey);
</code></pre><p>使用一个key提供者来获取算法:<br>  通过使用KeyProvider，您可以在运行时更改密钥，用于验证令牌签名或为RSA或ECDSA算法签署一个新的令牌。这是通过实现RSAKeyProvider或ECDSAKeyProvider方法实现的:</p>
<ul>
<li>getPublicKeyById(String kid): 它在令牌签名验证中调用，它应该返回用于验证令牌的密钥。如果使用了关键的轮换，例如JWK，它可以使用id来获取正确的轮换键(或者只是一直返回相同的键)。</li>
<li>getPrivateKey(): 在令牌签名期间调用它，它应该返回用于签署JWT的密钥。</li>
<li>getPrivateKeyId():在令牌签名期间调用它，它应该返回标识由getPrivateKey()返回的键的id的id。这个值比JWTCreator.Builder和keyid(String)方法中的值更受欢迎。如果您不需要设置孩子的值，就避免使用KeyProvider实例化算法。  </li>
</ul>
<h3 id="创建JWT"><a href="#创建JWT" class="headerlink" title="创建JWT"></a>创建JWT</h3><pre><code>try {
Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
String token = JWT.create()
    .withIssuer(&quot;auth0&quot;)
    .sign(algorithm);
} catch (UnsupportedEncodingException exception){
    //UTF-8 encoding not supported
} catch (JWTCreationException exception){
    //Invalid Signing configuration / Couldn&apos;t convert Claims.
}
</code></pre><p>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出JWTCreationException异常。</p>
<h3 id="验证令牌"><a href="#验证令牌" class="headerlink" title="验证令牌"></a>验证令牌</h3><p>首先需要通过调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。如果您要求令牌具有特定的Claim值，请使用构建器来定义它们。方法build()返回的实例是可重用的，因此您可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token</p>
<pre><code>String token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9.eyJpc3MiOiJhdXRoMCJ9.AbIJTDMFc7yUa5MhvcP03nJPyCPzZtQcGEp-zWfOkEE&quot;;
try {
    Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
    JWTVerifier verifier = JWT.require(algorithm)
        .withIssuer(&quot;auth0&quot;)
        .build(); //Reusable verifier instance
    DecodedJWT jwt = verifier.verify(token);
} catch (UnsupportedEncodingException exception){
    //UTF-8 encoding not supported
} catch (JWTVerificationException exception){
    //Invalid signature/claims
}
</code></pre><h3 id="时间验证"><a href="#时间验证" class="headerlink" title="时间验证"></a>时间验证</h3><p>当验证一个令牌时，时间验证会自动发生，导致在值无效时抛出一个JWTVerificationException。如果前面的任何一个字段都丢失了，那么在这个验证中就不会考虑这些字段。</p>
<p>要指定令牌仍然被认为有效的余地窗口，在JWTVerifier builder中使用accept回旋()方法，并传递一个正值的秒值。这适用于上面列出的每一项。</p>
<pre><code>JWTVerifier verifier = JWT.require(algorithm)
.acceptLeeway(1) // 1 sec for nbf, iat and exp
.build();
</code></pre><p>您还可以为给定的日期声明指定一个自定义值，并为该声明覆盖缺省值。</p>
<pre><code>JWTVerifier verifier = JWT.require(algorithm)
.acceptLeeway(1)   //1 sec for nbf and iat
.acceptExpiresAt(5)   //5 secs for exp
.build();
</code></pre><h3 id="信息解析"><a href="#信息解析" class="headerlink" title="信息解析"></a>信息解析</h3><h4 id="Algorithm-“alg”"><a href="#Algorithm-“alg”" class="headerlink" title="Algorithm (“alg”)"></a>Algorithm (“alg”)</h4><p>返回jwt的算法值或,如果没有定义则返回null</p>
<pre><code>String algorithm = jwt.getAlgorithm();
</code></pre><p>如果您需要在您的lib/app中测试此行为，将验证实例转换为basever可视化，以获得verific.build()方法的可见性，该方法可以接受定制的时钟。例如:</p>
<pre><code>BaseVerification verification = (BaseVerification) JWT.require(algorithm)
.acceptLeeway(1)
.acceptExpiresAt(5);
Clock clock = new CustomClock(); //Must implement Clock interface
JWTVerifier verifier = verification.build(clock);
</code></pre><h4 id="Type-“typ”"><a href="#Type-“typ”" class="headerlink" title="Type (“typ”)"></a>Type (“typ”)</h4><p>返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</p>
<pre><code>String type = jwt.getType();
</code></pre><h4 id="Content-Type-“cty”"><a href="#Content-Type-“cty”" class="headerlink" title="Content Type (“cty”)"></a>Content Type (“cty”)</h4><p>返回内容的类型,如果没有定义则返回null</p>
<pre><code>String contentType = jwt.getContentType();
</code></pre><h4 id="Key-Id-“kid”"><a href="#Key-Id-“kid”" class="headerlink" title="Key Id (“kid”)"></a>Key Id (“kid”)</h4><p>返回key的id值,如果没有定义则返回null</p>
<pre><code>String keyId = jwt.getKeyId();
</code></pre><h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><p>在令牌的头部中定义的附加声明可以通过调用getHeaderClaim() 获取,即使无法找到，也会返回。您可以通过调用claim.isNull()来检查声明的值是否为null。</p>
<pre><code>Claim claim = jwt.getHeaderClaim(&quot;owner&quot;);
</code></pre><p>当使用jwt.create()创建一个令牌时，您可以通过调用withHeader()来指定头声明，并同时传递声明的映射。</p>
<pre><code>Map&lt;String, Object&gt; headerClaims = new HashMap();
headerClaims.put(&quot;owner&quot;, &quot;auth0&quot;);
String token = JWT.create()
    .withHeader(headerClaims)
    .sign(algorithm);
</code></pre><p>提示:在签名过程之后，alg和typ值将始终包含在Header中。</p>
<h4 id="JWT的负载-Payload-声明"><a href="#JWT的负载-Payload-声明" class="headerlink" title="JWT的负载(Payload)声明"></a>JWT的负载(Payload)声明</h4><pre><code>Issuer (&quot;iss&quot;)
</code></pre><p>返回签发者的名称值,如果没有在负载中定义则返回null</p>
<pre><code>String issuer = jwt.getIssuer();
Subject (&quot;sub&quot;)
</code></pre><p>返回jwt所面向的用户的值,如果没有在负载中定义则返回null</p>
<pre><code>String subject = jwt.getSubject();
Audience (&quot;aud&quot;)
</code></pre><p>返回该jwt由谁接收,如果没有在负载中定义则返回null</p>
<pre><code>List&lt;String&gt; audience = jwt.getAudience();
Expiration Time (&quot;exp&quot;)
</code></pre><p>返回该jwt的过期时间,如果在负载中没有定义则返回null</p>
<pre><code>Date expiresAt = jwt.getExpiresAt();
Not Before (&quot;nbf&quot;)
</code></pre><p>Returns the Not Before value or null if it’s not defined in the Payload.</p>
<pre><code>Date notBefore = jwt.getNotBefore();
Issued At (&quot;iat&quot;)
</code></pre><p>返回在什么时候签发的,如果在负载中没有定义则返回null</p>
<pre><code>Date issuedAt = jwt.getIssuedAt();
JWT ID (&quot;jti&quot;)
</code></pre><p>返回该jwt的唯一标志,如果在负载中没有定义则返回null</p>
<pre><code>String id = jwt.getId();
</code></pre><h4 id="自定义声明"><a href="#自定义声明" class="headerlink" title="自定义声明"></a>自定义声明</h4><p>在令牌有效负载中定义的附加声明可以通过调用getClaims()或 getClaim()和传递声明名来获得。即使无法找到声明，也将会有返回值。您可以通过调用claim.isNull()来检查声明的值是否为null。</p>
<pre><code>Map&lt;String, Claim&gt; claims = jwt.getClaims();    //Key is the Claim name
Claim claim = claims.get(&quot;isAdmin&quot;);
</code></pre><p>或者:</p>
<pre><code>Claim claim = jwt.getClaim(&quot;isAdmin&quot;);
</code></pre><p>当使用jwt.create()创建一个令牌时，您可以通过调用withClaim()来指定自定义声明，并同时传递名称和值。</p>
<pre><code>String token = JWT.create()
    .withClaim(&quot;name&quot;, 123)
    .withArrayClaim(&quot;array&quot;, new Integer[]{1, 2, 3})
    .sign(algorithm);
</code></pre><p>您还可以通过调用withClaim()来验证jwt.require()的自定义声明，并传递该名称和所需的值。</p>
<pre><code>JWTVerifier verifier = JWT.require(algorithm)
    .withClaim(&quot;name&quot;, 123)
    .withArrayClaim(&quot;array&quot;, 1, 2, 3)
    .build();
DecodedJWT jwt = verifier.verify(&quot;my.jwt.token&quot;);    
</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>package course.utils;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.google.common.collect.Maps;
import course.pojo.User;

import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.Map;

public class JwtUtils {

    //创建token
    public static String creatToken(User user) throws IllegalArgumentException, UnsupportedEncodingException{
        Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
        String username = user.getUsername();
        Map&lt;String, Object&gt; map = Maps.newHashMap();
        map.put(&quot;alg&quot;, &quot;HS256&quot;);
        map.put(&quot;typ&quot;, &quot;JWT&quot;);
        String token = JWT.create().withHeader(map)
                .withClaim(&quot;username&quot;, username)
                .withExpiresAt(new Date(System.currentTimeMillis()+360000))
                .sign(algorithm);
        return token;
    }

    //验证jwt
    public static DecodedJWT verifyJwt(String token){
        DecodedJWT decodedJWT = null;
        try{
            Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
            JWTVerifier jwtVerifier = JWT.require(algorithm).build();
            decodedJWT = jwtVerifier.verify(token);
        }catch(IllegalArgumentException e){
            e.printStackTrace();
        }catch (UnsupportedEncodingException e){
            e.printStackTrace();
        }catch(JWTVerificationException e) {
            e.printStackTrace();
        }
        return decodedJWT;
    }

    public static void main(String[] args) throws UnsupportedEncodingException{
//        String username = &quot;root&quot;;
//        Integer id =1;
//        System.out.println(creatToken(username,id));
//        String token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MDgxMzgxNDAsInVzZXJJZCI6MSwidXNlcm5hbWUiOiJyb290In0.OeRdHJZKmxFBqIN-A-uSNQK8JyKdzX-wcFR883oMqFA&quot;;
//        System.out.println(verifyJwt(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MDgxMzgxNDAsInVzZXJJZCI6MSwidXNlcm5hbWUiOiJyb290In0.OeRdHJZKmxFBqIN-A-uSNQK8JyKdzX-wcFR883oMqFA&quot;));
//        System.out.println(verifyJwt(token).getClaims().get(&quot;username&quot;).asString());
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之线程池基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之线程池基础/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之线程池基础/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之线程池基础/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之线程池基础/">Java并发之线程池基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么设计线程池"><a href="#为什么设计线程池" class="headerlink" title="为什么设计线程池"></a>为什么设计线程池</h3><p>如果不使用线程池，当并发的线程数量很多，并且每个线程执行很短时间就结束，这要频繁创建线程会造成大量资源消，降低系统效率。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<h3 id="线程池构造函数"><a href="#线程池构造函数" class="headerlink" title="线程池构造函数"></a>线程池构造函数</h3><h4 id="源码构造方式一"><a href="#源码构造方式一" class="headerlink" title="源码构造方式一"></a>源码构造方式一</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
</code></pre><h4 id="源码构造方式二"><a href="#源码构造方式二" class="headerlink" title="源码构造方式二"></a>源码构造方式二</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}
</code></pre><h4 id="源码构造方式三"><a href="#源码构造方式三" class="headerlink" title="源码构造方式三"></a>源码构造方式三</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), handler);
}
</code></pre><h4 id="源码构造方式四"><a href="#源码构造方式四" class="headerlink" title="源码构造方式四"></a>源码构造方式四</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre><h4 id="源码构造函数分析"><a href="#源码构造函数分析" class="headerlink" title="源码构造函数分析"></a>源码构造函数分析</h4><p>前三个线程池构造函数都使用的this()来调用其他构造函数，而真正初始化作用的构造函数是第四个，所以前三个构造函数是基于第四个构造器初始化的。</p>
<p>下面详细说明每个参数的含义：</p>
<ul>
<li>corePollSize: 核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。<span style="color:red">在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</span></li>
<li>maximumPoolSize: 线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li>keepAliveTime: 线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。<span style="color:red">默认线程池的线程数大于线程池大小时起作用，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize，但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</span></li>
<li>workQueue: 一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响.</li>
</ul>
<pre><code>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。

PriorityBlockingQueue：一个具有优先级得无限阻塞队列。
</code></pre><ul>
<li>unit: 时间单位</li>
<li>threadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li>
<li>handler: 拒绝处理任务时的策略</li>
</ul>
<pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
</code></pre><p>再来看看以上的构造函数，可以发现四个构造函数在对threadFactory和handler的处理不同。</p>
<h3 id="线程池流程图"><a href="#线程池流程图" class="headerlink" title="线程池流程图"></a>线程池流程图</h3><p><img src="http://gityuan.com/images/android-process/thread-pool.jpg" alt=""></p>
<ul>
<li>1、当有新任务时，先判断线程数是否达到corePoolSize，未满的话直接继续创建新线程，满的话进入下一步。</li>
<li>2、判断工作队列workQueue是否已满，未满则将新任务添加到队列中等待，满的话进入下一步。</li>
<li>3、判断线程池是否达到maximumPoolSize，是的话按饱和策略处理，无法处理新任务，没有达到的话则继续创建线程。</li>
</ul>
<h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>ExecutorService是JDK并发工具包提供的一个核心接口，相当于一个线程池，提供执行任务和管理生命周期的方法。AbstractExecutorService主要实现了这个接口。<br>处理后的源码如下：</p>
<pre><code>public abstract class AbstractExecutorService implements ExecutorService {
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }
    //submit函数1
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    //submit函数2
    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    //submit函数3
    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,boolean timed, long nanos) throws InterruptedException, ExecutionException, TimeoutException {······}
    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException {······}
    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws InterruptedException {
}    
</code></pre><h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>源码如下所示：</p>
<pre><code>public interface ExecutorService extends Executor {
    void shutdown();
    List&lt;Runnable&gt; shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
    Future&lt;?&gt; submit(Runnable task);
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) throws InterruptedException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><pre><code>public interface Executor {
    void execute(Runnable command);
}
</code></pre><h3 id="各方法源码分析"><a href="#各方法源码分析" class="headerlink" title="各方法源码分析"></a>各方法源码分析</h3><p>在分析之前先梳理一下各个类和接口的实现继承关系。</p>
<pre><code>ThreadPoolExector——&gt;(extends)AbstractExecutorService——&gt;(implement)ExectorService——&gt;(implement)Executor
</code></pre><p>现在我们来依次分析：</p>
<h3 id="ThreadPoolExecutor类分析"><a href="#ThreadPoolExecutor类分析" class="headerlink" title="ThreadPoolExecutor类分析"></a>ThreadPoolExecutor类分析</h3><p>先看这个类的相关方法的使用与源码</p>
<h4 id="线程池状态码"><a href="#线程池状态码" class="headerlink" title="线程池状态码"></a>线程池状态码</h4><pre><code>volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
</code></pre><ul>
<li>当创建线程池后，初始时，线程池处于RUNNING状态；</li>
<li>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</li>
<li>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li>
<li>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</li>
</ul>
<h4 id="线程池成员变量"><a href="#线程池成员变量" class="headerlink" title="线程池成员变量"></a>线程池成员变量</h4><pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;              //任务缓存队列，用来存放等待执行的任务
private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（runState等）的改变都要使用这个锁
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();  //用来存放工作集
private volatile long  keepAliveTime;    //线程存货时间   
private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数
private volatile int   poolSize;       //线程池中当前的线程数
private volatile RejectedExecutionHandler handler; //任务拒绝策略
private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程
private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数
private long completedTaskCount;   //用来记录已经执行完毕的任务个数
</code></pre><h4 id="线程池的线程初始化"><a href="#线程池的线程初始化" class="headerlink" title="线程池的线程初始化"></a>线程池的线程初始化</h4><pre><code>//初始化核心线程池一个线程
public boolean prestartCoreThread() {
    return addIfUnderCorePoolSize(null); //注意传进去的参数是null
}
//初始化核心线程池所有线程
public int prestartAllCoreThreads() {
    int n = 0;
    while (addIfUnderCorePoolSize(null))//注意传进去的参数是null
        ++n;
    return n;
}
</code></pre><h4 id="execute-方法分析"><a href="#execute-方法分析" class="headerlink" title="execute()方法分析"></a>execute()方法分析</h4><p>首先是Executor接口中的execute的方法，为核心方法。这个方法主要在ThreadPoolExecutor中实现，这个方法可以向线程池提交一个任务，交由线程池去执行。源码如下：</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //获取ctl，主线程控制状态ctl是包装两个概念的原子整数，其中workerCount指代有效线程数，runState指代线程是运行还是停止等。
    int c = ctl.get();
    //保证增加工作线程时，ctl可以实时更新。
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    //保证任务可以在新线程或合并线程中运行
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}    
</code></pre><p>从传入的参数可知它是执行的实现Runnable接口的线程。  </p>
<h4 id="shutdown-方法分析"><a href="#shutdown-方法分析" class="headerlink" title="shutdown()方法分析"></a>shutdown()方法分析</h4><p>这个方法主要是有序关闭线程，先前提交的任务将会执行，但不会再接受新任务。一般执行关闭线程池任务主要使用shutdown()方法。</p>
<pre><code>public void shutdown() {
    //声明一个重入锁
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    //关闭线程
    try {
        //确保有权限关闭线程
        checkShutdownAccess();
        //将运行状态转化为跟定目标
        advanceRunState(SHUTDOWN);
        //中断线程，等待未执行的任务
        interruptIdleWorkers();
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
</code></pre><h4 id="ShutdownNow-方法分析"><a href="#ShutdownNow-方法分析" class="headerlink" title="ShutdownNow()方法分析"></a>ShutdownNow()方法分析</h4><p>中断所有已经执行的任务，并且不接受新的任务，源码与方法shutdown()类似。不同点是ShutdownNow()遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>
<pre><code>public List&lt;Runnable&gt; shutdownNow() {
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        interruptWorkers();
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
</code></pre><h4 id="isShutdown-方法分析"><a href="#isShutdown-方法分析" class="headerlink" title="isShutdown()方法分析"></a>isShutdown()方法分析</h4><p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。判断是否在关闭线程池。</p>
<pre><code>public boolean isShutdown() {
    return ! isRunning(ctl.get());
}
</code></pre><h4 id="isTerminated-方法分析"><a href="#isTerminated-方法分析" class="headerlink" title="isTerminated()方法分析"></a>isTerminated()方法分析</h4><p>当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p>
<pre><code>public boolean isTerminated() {
    return runStateAtLeast(ctl.get(), TERMINATED);
}
</code></pre><h4 id="remove-方法分析"><a href="#remove-方法分析" class="headerlink" title="remove()方法分析"></a>remove()方法分析</h4><p>移除线程池中正在执行的任务，线程未执行的话则不执行该方法。</p>
<pre><code>public boolean remove(Runnable task) {
    boolean removed = workQueue.remove(task);
    tryTerminate(); 
    return removed;
}
</code></pre><h4 id="purge-方法分析"><a href="#purge-方法分析" class="headerlink" title="purge()方法分析"></a>purge()方法分析</h4><p>删除线程池中所有已经被取消的任务，用于回收存储回收操作。    </p>
<pre><code>public void purge() {
    final BlockingQueue&lt;Runnable&gt; q = workQueue;
    try {
        Iterator&lt;Runnable&gt; it = q.iterator();
        while (it.hasNext()) {
            Runnable r = it.next();
            if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())
                it.remove();
        }
    } catch (ConcurrentModificationException fallThrough) {
        for (Object r : q.toArray())
            if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())
                q.remove(r);
    }
    tryTerminate(); 
}
</code></pre><h4 id="getPoolSize-方法分析"><a href="#getPoolSize-方法分析" class="headerlink" title="getPoolSize()方法分析"></a>getPoolSize()方法分析</h4><p>用于返回当前线程池存在的线程数量</p>
<pre><code>public int getPoolSize() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        return runStateAtLeast(ctl.get(), TIDYING) ? 0
            : workers.size();
    } finally {
        mainLock.unlock();
    }
}
</code></pre><h4 id="getActiveCount-方法分析"><a href="#getActiveCount-方法分析" class="headerlink" title="getActiveCount()方法分析"></a>getActiveCount()方法分析</h4><p>返回正在执行任务的线程数量</p>
<pre><code>  public int getActiveCount() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        int n = 0;
        for (Worker w : workers)
            if (w.isLocked())
                ++n;
        return n;
    } finally {
        mainLock.unlock();
    }
}
</code></pre><h4 id="getLargestPoolSize-方法分析"><a href="#getLargestPoolSize-方法分析" class="headerlink" title="getLargestPoolSize()方法分析"></a>getLargestPoolSize()方法分析</h4><p>返回线程池中曾经创建过的线程最大数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</p>
<pre><code>public int getLargestPoolSize() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        return largestPoolSize;
    } finally {
        mainLock.unlock();
    }
}
</code></pre><h4 id="getTaskCount-方法分析"><a href="#getTaskCount-方法分析" class="headerlink" title="getTaskCount()方法分析"></a>getTaskCount()方法分析</h4><p>返回计划任务数量的估计值(已经执行完的任务数+正在执行的任务数+工作队列等待的线程数)。</p>
<pre><code>public long getTaskCount() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //已经完成的任务数
            long n = completedTaskCount;
            //加上正在线程池执行的任务数
            for (Worker w : workers) {
                n += w.completedTasks;
                if (w.isLocked())
                    ++n;
            }
            //再加上工作队列中等待的任务数
            return n + workQueue.size();
        } finally {
            mainLock.unlock();
        }
    }
</code></pre><h4 id="getCompletedTaskCount-方法分析"><a href="#getCompletedTaskCount-方法分析" class="headerlink" title="getCompletedTaskCount()方法分析"></a>getCompletedTaskCount()方法分析</h4><p>返回已经完成的任务数，其实是已完成的加上正执行的任务数。源码和getTaskCount()基本类似。</p>
<h4 id="toString-方法分析"><a href="#toString-方法分析" class="headerlink" title="toString()方法分析"></a>toString()方法分析</h4><p>返回线程池的相关信息</p>
<pre><code>public String toString() {
    long ncompleted;
    int nworkers, nactive;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        ncompleted = completedTaskCount;
        nactive = 0;
        nworkers = workers.size();
        for (Worker w : workers) {
            ncompleted += w.completedTasks;
            if (w.isLocked())
                ++nactive;
        }
    } finally {
        mainLock.unlock();
    }
    int c = ctl.get();
    String rs = (runStateLessThan(c, SHUTDOWN) ? &quot;Running&quot; :
                 (runStateAtLeast(c, TERMINATED) ? &quot;Terminated&quot; :
                  &quot;Shutting down&quot;));
    return super.toString() +
        &quot;[&quot; + rs +
        &quot;, pool size = &quot; + nworkers +
        &quot;, active threads = &quot; + nactive +
        &quot;, queued tasks = &quot; + workQueue.size() +
        &quot;, completed tasks = &quot; + ncompleted +
        &quot;]&quot;;
}
</code></pre><h3 id="线程池简单示例"><a href="#线程池简单示例" class="headerlink" title="线程池简单示例"></a>线程池简单示例</h3><pre><code>public class Test {
     public static void main(String[] args) {   
         ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                 new ArrayBlockingQueue&lt;Runnable&gt;(5));

         for(int i=0;i&lt;15;i++){
             MyTask myTask = new MyTask(i);
             executor.execute(myTask);
             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+
             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());
         }
         executor.shutdown();
     }
}
class MyTask implements Runnable {
    private int taskNum;

    public MyTask(int num) {
        this.taskNum = num;
    }

    @Override
    public void run() {
        System.out.println(&quot;正在执行task &quot;+taskNum);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);
    }
}
</code></pre><p>在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p>
<pre><code>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
</code></pre><p>具体实现如下：</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
return new ThreadPoolExecutor(nThreads, nThreads,
                              0L, TimeUnit.MILLISECONDS,
                              new LinkedBlockingQueue&lt;Runnable&gt;());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><ul>
<li><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p>
</li>
<li><p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p>
</li>
<li><p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
</li>
</ul>
<h3 id="配置线程池大小"><a href="#配置线程池大小" class="headerlink" title="配置线程池大小"></a>配置线程池大小</h3><p>如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，如果线程池过小，那么会导致许多空闲的处理器无法执行工作，从而降低吞吐率。</p>
<p>NCPU是系统处理器的数量</p>
<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</p>
<p>如果是IO密集型任务，参考值可以设置为2*NCPU</p>
<p>　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之阻塞队列" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之阻塞队列/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之阻塞队列/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之阻塞队列/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之阻塞队列/">Java并发之阻塞队列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>使用非阻塞队列的时候有一个很大问题就是：它不会对当前线程产生阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。</p>
<h3 id="主要的阻塞队列"><a href="#主要的阻塞队列" class="headerlink" title="主要的阻塞队列"></a>主要的阻塞队列</h3><p>自从Java 1.5之后，在java.util.concurrent包下提供了若干个阻塞队列，主要有以下几个：</p>
<p>　　ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。</p>
<p>　　LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。</p>
<p>　　PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</p>
<p>　　DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<h3 id="阻塞队列中的方法-VS-非阻塞队列中的方法"><a href="#阻塞队列中的方法-VS-非阻塞队列中的方法" class="headerlink" title="阻塞队列中的方法 VS 非阻塞队列中的方法"></a>阻塞队列中的方法 VS 非阻塞队列中的方法</h3><p>1.非阻塞队列中的几个主要方法：</p>
<p>　　add(E e):将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</p>
<p>　　remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</p>
<p>　　offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</p>
<p>　　poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</p>
<p>　　peek()：获取队首元素，若成功，则返回队首元素；否则返回null</p>
<p>　　对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。</p>
<p>2.阻塞队列中的几个主要方法：</p>
<p>　　阻塞队列包括了非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在，但是要注意这5个方法在阻塞队列中都进行了同步措施。除此之外，阻塞队列提供了另外4个非常有用的方法：</p>
<p>　　put(E e)</p>
<p>　　take()</p>
<p>　　offer(E e,long timeout, TimeUnit unit)</p>
<p>　　poll(long timeout, TimeUnit unit)</p>
<p>　　</p>
<p>　　put方法用来向队尾存入元素，如果队列满，则等待；</p>
<p>　　take方法用来从队首取元素，如果队列为空，则等待；</p>
<p>　　offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</p>
<p>　　poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素；</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
implements BlockingQueue&lt;E&gt;, java.io.Serializable {

private static final long serialVersionUID = -817911632652898426L;

/** The queued items  */
private final E[] items;
/** items index for next take, poll or remove */
private int takeIndex;
/** items index for next put, offer, or add. */
private int putIndex;
/** Number of items in the queue */
private int count;

/*
* Concurrency control uses the classic two-condition algorithm
* found in any textbook.
*/

/** Main lock guarding all access */
private final ReentrantLock lock;
/** Condition for waiting takes */
private final Condition notEmpty;
/** Condition for waiting puts */
private final Condition notFull;
}
</code></pre><p> 　<br> 　<br> 　　可以看出，ArrayBlockingQueue中用来存储元素的实际上是一个数组，takeIndex和putIndex分别表示队首元素和队尾元素的下标，count表示队列中元素的个数。</p>
<p>　　lock是一个可重入锁，notEmpty和notFull是等待条件。</p>
<p>　　下面看一下ArrayBlockingQueue的构造器，构造器有三个重载版本：</p>
<pre><code>public ArrayBlockingQueue(int capacity) {
    }
public ArrayBlockingQueue(int capacity, boolean fair) {

    }
public ArrayBlockingQueue(int capacity, boolean fair,
                          Collection&lt;? extends E&gt; c) {
}
</code></pre><p> 　　第一个构造器只有一个参数用来指定容量，第二个构造器可以指定容量和公平性，第三个构造器可以指定容量、公平性以及用另外一个集合进行初始化。<br>然后看它的两个关键方法的实现：put()和take()：<br>　　<br>　  public void put(E e) throws InterruptedException {<br>        if (e == null) throw new NullPointerException();<br>        final E[] items = this.items;<br>        final ReentrantLock lock = this.lock;<br>        lock.lockInterruptibly();<br>        try {<br>            try {<br>                while (count == items.length)<br>                    notFull.await();<br>            } catch (InterruptedException ie) {<br>                notFull.signal(); // propagate to non-interrupted thread<br>                throw ie;<br>            }<br>            insert(e);<br>        } finally {<br>            lock.unlock();<br>        }<br>    }</p>
<p>从put方法的实现可以看出，它先获取了锁，并且获取的是可中断锁，然后判断当前元素个数是否等于数组的长度，如果相等，则调用notFull.await()进行等待，如果捕获到中断异常，则唤醒线程并抛出异常。</p>
<p>　　当被其他线程唤醒时，通过insert(e)方法插入元素，最后解锁。<br>我们看一下insert方法的实现：<br>　　<br>　 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　 private void <span class="keyword">insert(E </span>x) &#123;</div><div class="line">    items[putIndex] = x<span class="comment">;</span></div><div class="line">    putIndex = inc(putIndex)<span class="comment">;</span></div><div class="line">    ++<span class="built_in">count</span><span class="comment">;</span></div><div class="line">    notEmpty.signal()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它是一个private方法，插入成功后，通过notEmpty唤醒正在等待取元素的线程。</p>
<p>　　下面是take()方法的实现：<br>　　<br>　　<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</div><div class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</div><div class="line">    <span class="keyword">lock</span>.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">                notEmpty.<span class="keyword">await</span>();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">            notEmpty.signal(); <span class="comment">// propagate to non-interrupted thread</span></div><div class="line">            <span class="keyword">throw</span> ie;</div><div class="line">        &#125;</div><div class="line">        E x = extract();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">lock</span>.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟put方法实现很类似，只不过put方法等待的是notFull信号，而take方法等待的是notEmpty信号。在take方法中，如果可以取元素，则通过extract方法取得元素，下面是extract方法的实现：</p>
<pre><code>private E extract() {
    final E[] items = this.items;
    E x = items[takeIndex];
    items[takeIndex] = null;
    takeIndex = inc(takeIndex);
    --count;
    notFull.signal();
    return x;
}
</code></pre><p>跟insert方法也很类似。</p>
<p>其实从这里大家应该明白了阻塞队列的实现原理，事实它和我们用Object.wait()、Object.notify()和非阻塞队列实现生产者-消费者的思路类似，只不过它把这些工作一起集成到了阻塞队列中实现。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之线程池拓展—ExecutorService原理与静态工厂方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/">Java并发之线程池拓展—ExecutorService原理，静态工厂方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h2><p>这个类包含了所有的线程池静态工厂方法，我们一般使用工厂方法之一来创建一个线程池。</p>
<h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个 ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的 ExecutorService 的实现就是一个线程池的实现。</p>
<h3 id="任务委托"><a href="#任务委托" class="headerlink" title="任务委托"></a>任务委托</h3><p><img src="http://static.oschina.net/uploads/space/2013/1119/165710_YOvh_136226.png" alt=""></p>
<p>一旦线程把任务委托给 ExecutorService，该线程就会继续执行与运行任务无关的其它任务。</p>
<h3 id="ExecutorService的创建"><a href="#ExecutorService的创建" class="headerlink" title="ExecutorService的创建"></a>ExecutorService的创建</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool()"></a>newFixedThreadPool()</h4><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre><p>newFixedThreadPool创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到线程池的最大数量，这时线程池规模将不再变化（如果某个线程发生了未预期的Exception而结束，那么线程池会补充一个新的线程）</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h4><pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}
</code></pre><p>newSingleThreadExecutor是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个县城异常结束，会创建另一个线程来代替。能确保依照任务在队列中的顺序来执行任务。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h4><pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre><p>newCachedThreadPool将创建一个可缓存的线程池，这个工厂方法很重要，是个无界线程池，我们将会专门在另一篇文章讲这个方法。</p>
<p>如果线程池当前规模超过了处理需求时，将回收空闲的线程，当需求增加时，则可以添加新的线程，规模不u你在任何限制。</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool()"></a>newScheduledThreadPool()</h4><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
</code></pre><p>创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h3 id="ExecutorService使用方法"><a href="#ExecutorService使用方法" class="headerlink" title="ExecutorService使用方法"></a>ExecutorService使用方法</h3><p>主要是几个方法的使用，具体看我线程池的第一篇文章</p>
<pre><code>void shutdown();
List&lt;Runnable&gt; shutdownNow();
boolean isShutdown();
boolean isTerminated();
boolean awaitTermination(long timeout, TimeUnit unit)
    throws InterruptedException;
submit();
invokeAny();
invokeAll();
execute();
</code></pre><h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();
executorService.execute(new Runnable() {
    public void run() {
        System.out.println(&quot;Asynchronous task&quot;);
    }
});
executorService.shutdown();
</code></pre><p>使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用 接收 Callable 参数的 execute() 方法，后者将会在下文中提到。</p>
<h4 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h4><pre><code>Future future = executorService.submit(new Runnable() {
public void run() {
    System.out.println(&quot;Asynchronous task&quot;);
}
});
//如果任务结束执行则返回 null
System.out.println(&quot;future.get()=&quot; + future.get());
</code></pre><p>方法 submit(Callable) 和方法 submit(Runnable) 比较类似，但是区别则在于它们接收不同的参数类型。Callable 的实例与 Runnable 的实例很类似，但是 Callable 的 call() 方法可以返回壹個结果。方法 Runnable.run() 则不能返回结果。</p>
<p>Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。如下是一个 ExecutorService Callable 的样例：</p>
<pre><code>Future future = executorService.submit(new Callable(){
    public Object call() throws Exception {
        System.out.println(&quot;Asynchronous Callable&quot;);
        return &quot;Callable Result&quot;;
    }
});

System.out.println(&quot;future.get() = &quot; + future.get());
</code></pre><p>上述样例代码会输出如下结果：</p>
<pre><code>Asynchronous Callable
future.get() = Callable Result
</code></pre><h4 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h4><p>当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态。<br>举例来说，如果你的程序通过 main() 方法启动，并且主线程退出了你的程序，如果你还有一个活动的 ExecutorService 存在于你的程序中，那么程序将会继续保持运行状态。存在于 ExecutorService 中的活动线程会阻止Java虚拟机关闭。<br>为了关闭在 ExecutorService 中的线程，你需要调用 shutdown() 方法。ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorServie 才会真的关闭。所有在调用 shutdown() 方法之前提交到 ExecutorService 的任务都会执行。<br>如果你希望立即关闭 ExecutorService，你可以调用 shutdownNow() 方法。这个方法会尝试马上关闭所有正在执行的任务，并且跳过所有已经提交但是还没有运行的任务。但是对于正在执行的任务，是否能够成功关闭它是无法保证的，有可能他们真的被关闭掉了，也有可能它会一直执行到任务结束。这是一个最好的尝试。 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 Sams_ara Jin
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>


    

    
        <script id="dsq-count-scr" src="//.disqus.com/count.js" async></script>
        <script>
            if ($(".left-col").is(":visible")) {
                var $disqusCount = $(".disqus-comment-count");
                $disqusCount.bind("DOMNodeInserted", function(e) {
                    var num = $(this).text().replace(/[^0-9]/ig,"");
                    if (num > 0) {
                        $(this).siblings(".count-comment").text(num);
                    }
                    $(this).remove();
                })
            } else {
                $(".disqus-comment-count").remove();
            }
        </script>
     




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>