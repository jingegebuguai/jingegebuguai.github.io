<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="huiHui" />


    
    


<meta name="description" content="不屈于他人之下，技术永远没有尽头，不断进步才能生存">
<meta property="og:type" content="website">
<meta property="og:title" content="huiHui&#39;s blogs">
<meta property="og:url" content="http://huihui.kim/index.html">
<meta property="og:site_name" content="huiHui&#39;s blogs">
<meta property="og:description" content="不屈于他人之下，技术永远没有尽头，不断进步才能生存">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="huiHui&#39;s blogs">
<meta name="twitter:description" content="不屈于他人之下，技术永远没有尽头，不断进步才能生存">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="huiHui&#39;s blogs" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>huiHui&#39;s blogs</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">huiHui</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Java&amp;Python&amp;PHP&amp;Vue&amp;Angular全栈工程师</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/975715385@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/jingegebuguai" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa bilibili" href="http://bilibili.com" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS-ES6/">JS,ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS学习笔记/">JS学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java、linxu/">Java、linxu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LintCode/">LintCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lintcode/">Lintcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-angular/">js,angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://jingegebuguai.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于全栈</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">huiHui</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">huiHui</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Java&amp;Python&amp;PHP&amp;Vue&amp;Angular全栈工程师</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/975715385@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/jingegebuguai" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa bilibili" target="_blank" href="http://bilibili.com" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java并发之线程池拓展—ExecutorService原理与静态工厂方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之线程池拓展—ExecutorService原理与静态工厂方法/">Java并发之线程池拓展—ExecutorService原理，静态工厂方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h2><p>这个类包含了所有的线程池静态工厂方法，我们一般使用工厂方法之一来创建一个线程池。</p>
<h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个 ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的 ExecutorService 的实现就是一个线程池的实现。</p>
<h3 id="任务委托"><a href="#任务委托" class="headerlink" title="任务委托"></a>任务委托</h3><p><img src="http://static.oschina.net/uploads/space/2013/1119/165710_YOvh_136226.png" alt=""></p>
<p>一旦线程把任务委托给 ExecutorService，该线程就会继续执行与运行任务无关的其它任务。</p>
<h3 id="ExecutorService的创建"><a href="#ExecutorService的创建" class="headerlink" title="ExecutorService的创建"></a>ExecutorService的创建</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool()"></a>newFixedThreadPool()</h4><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre><p>newFixedThreadPool创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到线程池的最大数量，这时线程池规模将不再变化（如果某个线程发生了未预期的Exception而结束，那么线程池会补充一个新的线程）</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h4><pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}
</code></pre><p>newSingleThreadExecutor是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个县城异常结束，会创建另一个线程来代替。能确保依照任务在队列中的顺序来执行任务。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h4><pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre><p>newCachedThreadPool将创建一个可缓存的线程池，这个工厂方法很重要，是个无界线程池，我们将会专门在另一篇文章讲这个方法。</p>
<p>如果线程池当前规模超过了处理需求时，将回收空闲的线程，当需求增加时，则可以添加新的线程，规模不u你在任何限制。</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool()"></a>newScheduledThreadPool()</h4><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
</code></pre><p>创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h3 id="ExecutorService使用方法"><a href="#ExecutorService使用方法" class="headerlink" title="ExecutorService使用方法"></a>ExecutorService使用方法</h3><p>主要是几个方法的使用，具体看我线程池的第一篇文章</p>
<pre><code>void shutdown();
List&lt;Runnable&gt; shutdownNow();
boolean isShutdown();
boolean isTerminated();
boolean awaitTermination(long timeout, TimeUnit unit)
    throws InterruptedException;
submit();
invokeAny();
invokeAll();
execute();
</code></pre><h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();
executorService.execute(new Runnable() {
    public void run() {
        System.out.println(&quot;Asynchronous task&quot;);
    }
});
executorService.shutdown();
</code></pre><p>使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用 接收 Callable 参数的 execute() 方法，后者将会在下文中提到。</p>
<h4 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h4><pre><code>Future future = executorService.submit(new Runnable() {
public void run() {
    System.out.println(&quot;Asynchronous task&quot;);
}
});
//如果任务结束执行则返回 null
System.out.println(&quot;future.get()=&quot; + future.get());
</code></pre><p>方法 submit(Callable) 和方法 submit(Runnable) 比较类似，但是区别则在于它们接收不同的参数类型。Callable 的实例与 Runnable 的实例很类似，但是 Callable 的 call() 方法可以返回壹個结果。方法 Runnable.run() 则不能返回结果。</p>
<p>Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。如下是一个 ExecutorService Callable 的样例：</p>
<pre><code>Future future = executorService.submit(new Callable(){
    public Object call() throws Exception {
        System.out.println(&quot;Asynchronous Callable&quot;);
        return &quot;Callable Result&quot;;
    }
});

System.out.println(&quot;future.get() = &quot; + future.get());
</code></pre><p>上述样例代码会输出如下结果：</p>
<pre><code>Asynchronous Callable
future.get() = Callable Result
</code></pre><h4 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h4><p>当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态。<br>举例来说，如果你的程序通过 main() 方法启动，并且主线程退出了你的程序，如果你还有一个活动的 ExecutorService 存在于你的程序中，那么程序将会继续保持运行状态。存在于 ExecutorService 中的活动线程会阻止Java虚拟机关闭。<br>为了关闭在 ExecutorService 中的线程，你需要调用 shutdown() 方法。ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorServie 才会真的关闭。所有在调用 shutdown() 方法之前提交到 ExecutorService 的任务都会执行。<br>如果你希望立即关闭 ExecutorService，你可以调用 shutdownNow() 方法。这个方法会尝试马上关闭所有正在执行的任务，并且跳过所有已经提交但是还没有运行的任务。但是对于正在执行的任务，是否能够成功关闭它是无法保证的，有可能他们真的被关闭掉了，也有可能它会一直执行到任务结束。这是一个最好的尝试。 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之线程池拓展—Callable，Future，FutureTask" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之线程池拓展—Callable，Future，FutureTask/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之线程池拓展—Callable，Future，FutureTask/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之线程池拓展—Callable，Future，FutureTask/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之线程池拓展—Callable，Future，FutureTask/">Java并发之线程池—Callable,Future,FutureTask</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="AbstractExecutorService类源码分析"><a href="#AbstractExecutorService类源码分析" class="headerlink" title="AbstractExecutorService类源码分析"></a>AbstractExecutorService类源码分析</h2><p>线程池ThreadPoolExecutor继承于AbstractorExecutorService类，所以分析该类的构成很有必要。</p>
<p>上一篇博文提到ExecutorService是JDK并发工具包提供的一个核心接口，相当于一个线程池，提供执行任务和管理生命周期的方法。AbstractExecutorService主要实现了这个接口。 处理后的源码如下：</p>
<pre><code>public abstract class AbstractExecutorService implements ExecutorService {
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }
    //submit函数1
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    //submit函数2
    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    //submit函数3
    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,boolean timed, long nanos) throws InterruptedException, ExecutionException, TimeoutException {······}
    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException {······}
    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws InterruptedException {
}
</code></pre><h3 id="submit-方法源码分析"><a href="#submit-方法源码分析" class="headerlink" title="submit()方法源码分析"></a>submit()方法源码分析</h3><p>下面三个submit()方法是ExecutorService接口中的，并且由AbstructExecutorService类具体实现。    </p>
<pre><code>public Future&lt;?&gt; submit(Runnable task) {···}

public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {···}

public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {···}
</code></pre><h4 id="Callable-接口源码"><a href="#Callable-接口源码" class="headerlink" title="Callable()接口源码"></a>Callable()接口源码</h4><pre><code>@FunctionalInterface
public interface Callable&lt;V&gt; {
    //计算结果
    V call() throws Exception;
}
</code></pre><h4 id="newTaskFor-方法源码"><a href="#newTaskFor-方法源码" class="headerlink" title="newTaskFor()方法源码"></a>newTaskFor()方法源码</h4><pre><code>protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }
protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }
</code></pre><h4 id="FutureTask类部分源码"><a href="#FutureTask类部分源码" class="headerlink" title="FutureTask类部分源码"></a>FutureTask类部分源码</h4><pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    ···
    public FutureTask(Callable&lt;V&gt; callable) {···}
    public FutureTask(Runnable runnable, V result) {···}
    ···
}
</code></pre><h4 id="RunnableFuture接口源码"><a href="#RunnableFuture接口源码" class="headerlink" title="RunnableFuture接口源码"></a>RunnableFuture接口源码</h4><pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    void run();
}
</code></pre><h4 id="Runnable接口源码"><a href="#Runnable接口源码" class="headerlink" title="Runnable接口源码"></a>Runnable接口源码</h4><pre><code>@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
</code></pre><h4 id="Future接口源码"><a href="#Future接口源码" class="headerlink" title="Future接口源码"></a>Future接口源码</h4><pre><code>public interface Future&lt;V&gt; {
    //试图取消对任务的执行,参数为true表示可以取消正在执行的任务
    boolean cancel(boolean mayInterruptIfRunning);
    //任务是否取消成功
    boolean isCancelled();
    //任务是否已经完成
    boolean isDone();
    //获取执行结果，会产生阻塞，等到任务执行完再返回结果
    V get() throws InterruptedException, ExecutionException;
    //在指定时间内未返回结果，则返回null
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre><p>从上述源码可知，想要分析submit()方法，转接这需要分析很多FutureTask类和若干接口。梳理一下如下所示</p>
<pre><code>ThreadPoolExecutor--&gt;(extends)AbstractExecutorService
AbstractExecutorService--&gt;具有三个submit()方法,参数类型包括Runnable,Callable
submit()--&gt;返回FutureTask类对象--&gt;(implements)RunnableFuture--&gt;(extends)Runnable,Future
</code></pre><p>我们来看Callable接口，从源码可知，这个接口只有一个call()方法，用以调用并返回结果，和Runnable相似，用以返回一个对象或异常。</p>
<p>Call接口使用泛型定义返回类型，Executors类提供了一些有用的方法在线程池中执行Callable内的任务。由于Callable任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。</p>
<p>java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。</p>
<p>可以用ExecutorService接口中的submit()方法实现这个功能,submit()负责向线程池提交Callable任务,然后返回Future对象，我们在借助Future对象的get()方法获取Callable接口中call()方法的结果：</p>
<pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
</code></pre><h5 id="submit-具体实现源码"><a href="#submit-具体实现源码" class="headerlink" title="submit()具体实现源码"></a>submit()具体实现源码</h5><pre><code>public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
    //Callable任务为空，抛出无参异常
    if (task == null) throw new NullPointerException();
    //返回FutureTask类对象,
    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
    //向线程池提交一个任务
    execute(ftask);
    //返回处理后的任务
    return ftask;
}
</code></pre><p>我们分析的是传入Callable类型参数的submit方法，其实其他两个源码都类似， 注解基本都已经备注好，第一步判断参数的有无，我们来看看第二步返回是FutureTask类的对象，注意这个类实现的是RunnableFuture接口，而这个接口继承的又是Runnable和Future接口<span style="color:red">(接口也是可以extends接口的哦！)</span>。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。来看第二步代码FutureTask类的构造函数源码：</p>
<pre><code>public FutureTask(Callable&lt;V&gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;      
}
</code></pre><p>FutureTask类实现了Future接口的一系列方法，如get()。第三步是向线程池提交任务，最后返回这个任务，下面看一个实例：</p>
<h5 id="Callable-Future示例"><a href="#Callable-Future示例" class="headerlink" title="Callable,Future示例"></a>Callable,Future示例</h5><pre><code>public class Test {
    public static void main(String[] args) {
        //建议使用Executors类中的方法构建线程池，具体使用方法和源码分析看我关于线程池本主题的其他博文
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future&lt;Integer&gt; result = executor.submit(task);
        executor.shutdown();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }

        System.out.println(&quot;主线程在执行任务&quot;);

        try {
            System.out.println(&quot;task运行结果&quot;+result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;所有任务执行完毕&quot;);
    }
}
class Task implements Callable&lt;Integer&gt;{
    @Override
    public Integer call() throws Exception {
        System.out.println(&quot;子线程在进行计算&quot;);
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i&lt;100;i++)
            sum += i;
        return sum;
    }
}
</code></pre><p>执行结果如下：</p>
<pre><code>子线程在进行计算
主线程在执行任务
task运行结果4950
所有任务执行完毕
</code></pre><h5 id="Callable-FutureTask示例"><a href="#Callable-FutureTask示例" class="headerlink" title="Callable,FutureTask示例"></a>Callable,FutureTask示例</h5><pre><code>public class Test {
    public static void main(String[] args) {
        //第一种方式，线程池方式
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);
        executor.submit(futureTask);
        executor.shutdown();

        //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread
        /*Task task = new Task();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);
        Thread thread = new Thread(futureTask);
        thread.start();*/

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }

        System.out.println(&quot;主线程在执行任务&quot;);

        try {
            System.out.println(&quot;task运行结果&quot;+futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;所有任务执行完毕&quot;);
    }
}
class Task implements Callable&lt;Integer&gt;{
    @Override
    public Integer call() throws Exception {
        System.out.println(&quot;子线程在进行计算&quot;);
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i&lt;100;i++)
            sum += i;
        return sum;
    }
}
</code></pre><p>上面一段代码是对Callable+FutureTask方法的演示，若是Runnable+FutureTask也可以用此调用方式，只是task类中的不是call方法，而是实现run方法。</p>
<p>如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之线程池基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之线程池基础/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之线程池基础/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之线程池基础/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之线程池基础/">Java并发之线程池基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么设计线程池"><a href="#为什么设计线程池" class="headerlink" title="为什么设计线程池"></a>为什么设计线程池</h3><p>如果不使用线程池，当并发的线程数量很多，并且每个线程执行很短时间就结束，这要频繁创建线程会造成大量资源消，降低系统效率。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<h3 id="线程池构造函数"><a href="#线程池构造函数" class="headerlink" title="线程池构造函数"></a>线程池构造函数</h3><h4 id="源码构造方式一"><a href="#源码构造方式一" class="headerlink" title="源码构造方式一"></a>源码构造方式一</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
</code></pre><h4 id="源码构造方式二"><a href="#源码构造方式二" class="headerlink" title="源码构造方式二"></a>源码构造方式二</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}
</code></pre><h4 id="源码构造方式三"><a href="#源码构造方式三" class="headerlink" title="源码构造方式三"></a>源码构造方式三</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), handler);
}
</code></pre><h4 id="源码构造方式四"><a href="#源码构造方式四" class="headerlink" title="源码构造方式四"></a>源码构造方式四</h4><pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre><h4 id="源码构造函数分析"><a href="#源码构造函数分析" class="headerlink" title="源码构造函数分析"></a>源码构造函数分析</h4><p>前三个线程池构造函数都使用的this()来调用其他构造函数，而真正初始化作用的构造函数是第四个，所以前三个构造函数是基于第四个构造器初始化的。</p>
<p>下面详细说明每个参数的含义：</p>
<ul>
<li>corePollSize: 核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。<span style="color:red">在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</span></li>
<li>maximumPoolSize: 线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li>keepAliveTime: 线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。<span style="color:red">默认线程池的线程数大于线程池大小时起作用，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize，但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</span></li>
<li>workQueue: 一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响.</li>
</ul>
<pre><code>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。

PriorityBlockingQueue：一个具有优先级得无限阻塞队列。
</code></pre><ul>
<li>unit: 时间单位</li>
<li>threadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li>
<li>handler: 拒绝处理任务时的策略</li>
</ul>
<pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
</code></pre><p>再来看看以上的构造函数，可以发现四个构造函数在对threadFactory和handler的处理不同。</p>
<h3 id="线程池流程图"><a href="#线程池流程图" class="headerlink" title="线程池流程图"></a>线程池流程图</h3><p><img src="http://gityuan.com/images/android-process/thread-pool.jpg" alt=""></p>
<ul>
<li>1、当有新任务时，先判断线程数是否达到corePoolSize，未满的话直接继续创建新线程，满的话进入下一步。</li>
<li>2、判断工作队列workQueue是否已满，未满则将新任务添加到队列中等待，满的话进入下一步。</li>
<li>3、判断线程池是否达到maximumPoolSize，是的话按饱和策略处理，无法处理新任务，没有达到的话则继续创建线程。</li>
</ul>
<h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>ExecutorService是JDK并发工具包提供的一个核心接口，相当于一个线程池，提供执行任务和管理生命周期的方法。AbstractExecutorService主要实现了这个接口。<br>处理后的源码如下：</p>
<pre><code>public abstract class AbstractExecutorService implements ExecutorService {
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }
    //submit函数1
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    //submit函数2
    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    //submit函数3
    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,boolean timed, long nanos) throws InterruptedException, ExecutionException, TimeoutException {······}
    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException {······}
    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws InterruptedException {
}    
</code></pre><h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>源码如下所示：</p>
<pre><code>public interface ExecutorService extends Executor {
    void shutdown();
    List&lt;Runnable&gt; shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
    Future&lt;?&gt; submit(Runnable task);
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) throws InterruptedException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><pre><code>public interface Executor {
    void execute(Runnable command);
}
</code></pre><h3 id="各方法源码分析"><a href="#各方法源码分析" class="headerlink" title="各方法源码分析"></a>各方法源码分析</h3><p>在分析之前先梳理一下各个类和接口的实现继承关系。</p>
<pre><code>ThreadPoolExector——&gt;(extends)AbstractExecutorService——&gt;(implement)ExectorService——&gt;(implement)Executor
</code></pre><p>现在我们来依次分析：</p>
<h3 id="ThreadPoolExecutor类分析"><a href="#ThreadPoolExecutor类分析" class="headerlink" title="ThreadPoolExecutor类分析"></a>ThreadPoolExecutor类分析</h3><p>先看这个类的相关方法的使用与源码</p>
<h4 id="线程池状态码"><a href="#线程池状态码" class="headerlink" title="线程池状态码"></a>线程池状态码</h4><pre><code>volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
</code></pre><ul>
<li>当创建线程池后，初始时，线程池处于RUNNING状态；</li>
<li>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</li>
<li>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li>
<li>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</li>
</ul>
<h4 id="线程池成员变量"><a href="#线程池成员变量" class="headerlink" title="线程池成员变量"></a>线程池成员变量</h4><pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;              //任务缓存队列，用来存放等待执行的任务
private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（runState等）的改变都要使用这个锁
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();  //用来存放工作集
private volatile long  keepAliveTime;    //线程存货时间   
private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数
private volatile int   poolSize;       //线程池中当前的线程数
private volatile RejectedExecutionHandler handler; //任务拒绝策略
private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程
private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数
private long completedTaskCount;   //用来记录已经执行完毕的任务个数
</code></pre><h4 id="线程池的线程初始化"><a href="#线程池的线程初始化" class="headerlink" title="线程池的线程初始化"></a>线程池的线程初始化</h4><pre><code>//初始化核心线程池一个线程
public boolean prestartCoreThread() {
    return addIfUnderCorePoolSize(null); //注意传进去的参数是null
}
//初始化核心线程池所有线程
public int prestartAllCoreThreads() {
    int n = 0;
    while (addIfUnderCorePoolSize(null))//注意传进去的参数是null
        ++n;
    return n;
}
</code></pre><h4 id="execute-方法分析"><a href="#execute-方法分析" class="headerlink" title="execute()方法分析"></a>execute()方法分析</h4><p>首先是Executor接口中的execute的方法，为核心方法。这个方法主要在ThreadPoolExecutor中实现，这个方法可以向线程池提交一个任务，交由线程池去执行。源码如下：</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //获取ctl，主线程控制状态ctl是包装两个概念的原子整数，其中workerCount指代有效线程数，runState指代线程是运行还是停止等。
    int c = ctl.get();
    //保证增加工作线程时，ctl可以实时更新。
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    //保证任务可以在新线程或合并线程中运行
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}    
</code></pre><p>从传入的参数可知它是执行的实现Runnable接口的线程。  </p>
<h4 id="shutdown-方法分析"><a href="#shutdown-方法分析" class="headerlink" title="shutdown()方法分析"></a>shutdown()方法分析</h4><p>这个方法主要是有序关闭线程，先前提交的任务将会执行，但不会再接受新任务。一般执行关闭线程池任务主要使用shutdown()方法。</p>
<pre><code>public void shutdown() {
    //声明一个重入锁
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    //关闭线程
    try {
        //确保有权限关闭线程
        checkShutdownAccess();
        //将运行状态转化为跟定目标
        advanceRunState(SHUTDOWN);
        //中断线程，等待未执行的任务
        interruptIdleWorkers();
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
</code></pre><h4 id="ShutdownNow-方法分析"><a href="#ShutdownNow-方法分析" class="headerlink" title="ShutdownNow()方法分析"></a>ShutdownNow()方法分析</h4><p>中断所有已经执行的任务，并且不接受新的任务，源码与方法shutdown()类似。不同点是ShutdownNow()遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>
<pre><code>public List&lt;Runnable&gt; shutdownNow() {
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        interruptWorkers();
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
</code></pre><h4 id="isShutdown-方法分析"><a href="#isShutdown-方法分析" class="headerlink" title="isShutdown()方法分析"></a>isShutdown()方法分析</h4><p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。判断是否在关闭线程池。</p>
<pre><code>public boolean isShutdown() {
    return ! isRunning(ctl.get());
}
</code></pre><h4 id="isTerminated-方法分析"><a href="#isTerminated-方法分析" class="headerlink" title="isTerminated()方法分析"></a>isTerminated()方法分析</h4><p>当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p>
<pre><code>public boolean isTerminated() {
    return runStateAtLeast(ctl.get(), TERMINATED);
}
</code></pre><h4 id="remove-方法分析"><a href="#remove-方法分析" class="headerlink" title="remove()方法分析"></a>remove()方法分析</h4><p>移除线程池中正在执行的任务，线程未执行的话则不执行该方法。</p>
<pre><code>public boolean remove(Runnable task) {
    boolean removed = workQueue.remove(task);
    tryTerminate(); 
    return removed;
}
</code></pre><h4 id="purge-方法分析"><a href="#purge-方法分析" class="headerlink" title="purge()方法分析"></a>purge()方法分析</h4><p>删除线程池中所有已经被取消的任务，用于回收存储回收操作。    </p>
<pre><code>public void purge() {
    final BlockingQueue&lt;Runnable&gt; q = workQueue;
    try {
        Iterator&lt;Runnable&gt; it = q.iterator();
        while (it.hasNext()) {
            Runnable r = it.next();
            if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())
                it.remove();
        }
    } catch (ConcurrentModificationException fallThrough) {
        for (Object r : q.toArray())
            if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())
                q.remove(r);
    }
    tryTerminate(); 
}
</code></pre><h4 id="getPoolSize-方法分析"><a href="#getPoolSize-方法分析" class="headerlink" title="getPoolSize()方法分析"></a>getPoolSize()方法分析</h4><p>用于返回当前线程池存在的线程数量</p>
<pre><code>public int getPoolSize() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        return runStateAtLeast(ctl.get(), TIDYING) ? 0
            : workers.size();
    } finally {
        mainLock.unlock();
    }
}
</code></pre><h4 id="getActiveCount-方法分析"><a href="#getActiveCount-方法分析" class="headerlink" title="getActiveCount()方法分析"></a>getActiveCount()方法分析</h4><p>返回正在执行任务的线程数量</p>
<pre><code>  public int getActiveCount() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        int n = 0;
        for (Worker w : workers)
            if (w.isLocked())
                ++n;
        return n;
    } finally {
        mainLock.unlock();
    }
}
</code></pre><h4 id="getLargestPoolSize-方法分析"><a href="#getLargestPoolSize-方法分析" class="headerlink" title="getLargestPoolSize()方法分析"></a>getLargestPoolSize()方法分析</h4><p>返回线程池中曾经创建过的线程最大数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</p>
<pre><code>public int getLargestPoolSize() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        return largestPoolSize;
    } finally {
        mainLock.unlock();
    }
}
</code></pre><h4 id="getTaskCount-方法分析"><a href="#getTaskCount-方法分析" class="headerlink" title="getTaskCount()方法分析"></a>getTaskCount()方法分析</h4><p>返回计划任务数量的估计值(已经执行完的任务数+正在执行的任务数+工作队列等待的线程数)。</p>
<pre><code>public long getTaskCount() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //已经完成的任务数
            long n = completedTaskCount;
            //加上正在线程池执行的任务数
            for (Worker w : workers) {
                n += w.completedTasks;
                if (w.isLocked())
                    ++n;
            }
            //再加上工作队列中等待的任务数
            return n + workQueue.size();
        } finally {
            mainLock.unlock();
        }
    }
</code></pre><h4 id="getCompletedTaskCount-方法分析"><a href="#getCompletedTaskCount-方法分析" class="headerlink" title="getCompletedTaskCount()方法分析"></a>getCompletedTaskCount()方法分析</h4><p>返回已经完成的任务数，其实是已完成的加上正执行的任务数。源码和getTaskCount()基本类似。</p>
<h4 id="toString-方法分析"><a href="#toString-方法分析" class="headerlink" title="toString()方法分析"></a>toString()方法分析</h4><p>返回线程池的相关信息</p>
<pre><code>public String toString() {
    long ncompleted;
    int nworkers, nactive;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        ncompleted = completedTaskCount;
        nactive = 0;
        nworkers = workers.size();
        for (Worker w : workers) {
            ncompleted += w.completedTasks;
            if (w.isLocked())
                ++nactive;
        }
    } finally {
        mainLock.unlock();
    }
    int c = ctl.get();
    String rs = (runStateLessThan(c, SHUTDOWN) ? &quot;Running&quot; :
                 (runStateAtLeast(c, TERMINATED) ? &quot;Terminated&quot; :
                  &quot;Shutting down&quot;));
    return super.toString() +
        &quot;[&quot; + rs +
        &quot;, pool size = &quot; + nworkers +
        &quot;, active threads = &quot; + nactive +
        &quot;, queued tasks = &quot; + workQueue.size() +
        &quot;, completed tasks = &quot; + ncompleted +
        &quot;]&quot;;
}
</code></pre><h3 id="线程池简单示例"><a href="#线程池简单示例" class="headerlink" title="线程池简单示例"></a>线程池简单示例</h3><pre><code>public class Test {
     public static void main(String[] args) {   
         ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                 new ArrayBlockingQueue&lt;Runnable&gt;(5));

         for(int i=0;i&lt;15;i++){
             MyTask myTask = new MyTask(i);
             executor.execute(myTask);
             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+
             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());
         }
         executor.shutdown();
     }
}
class MyTask implements Runnable {
    private int taskNum;

    public MyTask(int num) {
        this.taskNum = num;
    }

    @Override
    public void run() {
        System.out.println(&quot;正在执行task &quot;+taskNum);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);
    }
}
</code></pre><p>在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p>
<pre><code>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
</code></pre><p>具体实现如下：</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
return new ThreadPoolExecutor(nThreads, nThreads,
                              0L, TimeUnit.MILLISECONDS,
                              new LinkedBlockingQueue&lt;Runnable&gt;());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><ul>
<li><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p>
</li>
<li><p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p>
</li>
<li><p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
</li>
</ul>
<h3 id="配置线程池大小"><a href="#配置线程池大小" class="headerlink" title="配置线程池大小"></a>配置线程池大小</h3><p>如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，如果线程池过小，那么会导致许多空闲的处理器无法执行工作，从而降低吞吐率。</p>
<p>NCPU是系统处理器的数量</p>
<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</p>
<p>如果是IO密集型任务，参考值可以设置为2*NCPU</p>
<p>　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之阻塞队列" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/01/Java并发之阻塞队列/" class="article-date">
      <time datetime="2017-11-01T02:35:00.000Z" itemprop="datePublished">2017-11-01</time>
</a>

 
    <a href="/2017/11/01/Java并发之阻塞队列/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/11/01/Java并发之阻塞队列/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/Java并发之阻塞队列/">Java并发之阻塞队列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>使用非阻塞队列的时候有一个很大问题就是：它不会对当前线程产生阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。</p>
<h3 id="主要的阻塞队列"><a href="#主要的阻塞队列" class="headerlink" title="主要的阻塞队列"></a>主要的阻塞队列</h3><p>自从Java 1.5之后，在java.util.concurrent包下提供了若干个阻塞队列，主要有以下几个：</p>
<p>　　ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。</p>
<p>　　LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。</p>
<p>　　PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</p>
<p>　　DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<h3 id="阻塞队列中的方法-VS-非阻塞队列中的方法"><a href="#阻塞队列中的方法-VS-非阻塞队列中的方法" class="headerlink" title="阻塞队列中的方法 VS 非阻塞队列中的方法"></a>阻塞队列中的方法 VS 非阻塞队列中的方法</h3><p>1.非阻塞队列中的几个主要方法：</p>
<p>　　add(E e):将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</p>
<p>　　remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</p>
<p>　　offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</p>
<p>　　poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</p>
<p>　　peek()：获取队首元素，若成功，则返回队首元素；否则返回null</p>
<p>　　对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。</p>
<p>2.阻塞队列中的几个主要方法：</p>
<p>　　阻塞队列包括了非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在，但是要注意这5个方法在阻塞队列中都进行了同步措施。除此之外，阻塞队列提供了另外4个非常有用的方法：</p>
<p>　　put(E e)</p>
<p>　　take()</p>
<p>　　offer(E e,long timeout, TimeUnit unit)</p>
<p>　　poll(long timeout, TimeUnit unit)</p>
<p>　　</p>
<p>　　put方法用来向队尾存入元素，如果队列满，则等待；</p>
<p>　　take方法用来从队首取元素，如果队列为空，则等待；</p>
<p>　　offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</p>
<p>　　poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素；</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
implements BlockingQueue&lt;E&gt;, java.io.Serializable {

private static final long serialVersionUID = -817911632652898426L;

/** The queued items  */
private final E[] items;
/** items index for next take, poll or remove */
private int takeIndex;
/** items index for next put, offer, or add. */
private int putIndex;
/** Number of items in the queue */
private int count;

/*
* Concurrency control uses the classic two-condition algorithm
* found in any textbook.
*/

/** Main lock guarding all access */
private final ReentrantLock lock;
/** Condition for waiting takes */
private final Condition notEmpty;
/** Condition for waiting puts */
private final Condition notFull;
}
</code></pre><p> 　<br> 　<br> 　　可以看出，ArrayBlockingQueue中用来存储元素的实际上是一个数组，takeIndex和putIndex分别表示队首元素和队尾元素的下标，count表示队列中元素的个数。</p>
<p>　　lock是一个可重入锁，notEmpty和notFull是等待条件。</p>
<p>　　下面看一下ArrayBlockingQueue的构造器，构造器有三个重载版本：</p>
<pre><code>public ArrayBlockingQueue(int capacity) {
    }
public ArrayBlockingQueue(int capacity, boolean fair) {

    }
public ArrayBlockingQueue(int capacity, boolean fair,
                          Collection&lt;? extends E&gt; c) {
}
</code></pre><p> 　　第一个构造器只有一个参数用来指定容量，第二个构造器可以指定容量和公平性，第三个构造器可以指定容量、公平性以及用另外一个集合进行初始化。<br>然后看它的两个关键方法的实现：put()和take()：<br>　　<br>　  public void put(E e) throws InterruptedException {<br>        if (e == null) throw new NullPointerException();<br>        final E[] items = this.items;<br>        final ReentrantLock lock = this.lock;<br>        lock.lockInterruptibly();<br>        try {<br>            try {<br>                while (count == items.length)<br>                    notFull.await();<br>            } catch (InterruptedException ie) {<br>                notFull.signal(); // propagate to non-interrupted thread<br>                throw ie;<br>            }<br>            insert(e);<br>        } finally {<br>            lock.unlock();<br>        }<br>    }</p>
<p>从put方法的实现可以看出，它先获取了锁，并且获取的是可中断锁，然后判断当前元素个数是否等于数组的长度，如果相等，则调用notFull.await()进行等待，如果捕获到中断异常，则唤醒线程并抛出异常。</p>
<p>　　当被其他线程唤醒时，通过insert(e)方法插入元素，最后解锁。<br>我们看一下insert方法的实现：<br>　　<br>　 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　 private void <span class="keyword">insert(E </span>x) &#123;</div><div class="line">    items[putIndex] = x<span class="comment">;</span></div><div class="line">    putIndex = inc(putIndex)<span class="comment">;</span></div><div class="line">    ++<span class="built_in">count</span><span class="comment">;</span></div><div class="line">    notEmpty.signal()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它是一个private方法，插入成功后，通过notEmpty唤醒正在等待取元素的线程。</p>
<p>　　下面是take()方法的实现：<br>　　<br>　　<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</div><div class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</div><div class="line">    <span class="keyword">lock</span>.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">                notEmpty.<span class="keyword">await</span>();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">            notEmpty.signal(); <span class="comment">// propagate to non-interrupted thread</span></div><div class="line">            <span class="keyword">throw</span> ie;</div><div class="line">        &#125;</div><div class="line">        E x = extract();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">lock</span>.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟put方法实现很类似，只不过put方法等待的是notFull信号，而take方法等待的是notEmpty信号。在take方法中，如果可以取元素，则通过extract方法取得元素，下面是extract方法的实现：</p>
<pre><code>private E extract() {
    final E[] items = this.items;
    E x = items[takeIndex];
    items[takeIndex] = null;
    takeIndex = inc(takeIndex);
    --count;
    notFull.signal();
    return x;
}
</code></pre><p>跟insert方法也很类似。</p>
<p>其实从这里大家应该明白了阻塞队列的实现原理，事实它和我们用Object.wait()、Object.notify()和非阻塞队列实现生产者-消费者的思路类似，只不过它把这些工作一起集成到了阻塞队列中实现。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-LintCode题解--中等篇(1)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/27/LintCode题解--中等篇(1)/" class="article-date">
      <time datetime="2017-10-27T06:14:00.000Z" itemprop="datePublished">2017-10-27</time>
</a>

 
    <a href="/2017/10/27/LintCode题解--中等篇(1)/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/10/27/LintCode题解--中等篇(1)/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/27/LintCode题解--中等篇(1)/">LintCode题解——中等篇（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>容易题刷烂了，略感无趣</p>
<h2 id="三角形计数"><a href="#三角形计数" class="headerlink" title="三角形计数"></a>三角形计数</h2><p>给定一个整数数组，在该数组中，寻找三个数，分别代表三角形三条边的长度，问，可以寻找到多少组这样的三个数来组成三角形？</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>例如，给定数组 S = {3,4,6,7}，返回 3</p>
<p>其中我们可以找到的三个三角形为：</p>
<pre><code>{3,4,6}
{3,6,7}
{4,6,7}
</code></pre><p>给定数组 S = {4,4,4,4}, 返回 4</p>
<p>其中我们可以找到的三个三角形为：</p>
<pre><code>{4(1),4(2),4(3)}
{4(1),4(2),4(4)}
{4(1),4(3),4(4)}
{4(2),4(3),4(4)}
</code></pre><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>这题按道理算不上是中等题，其实最暴力的方法就是来个三重for循环，每次取三个数，把所有数的组合都尝试一遍，判断每个组合是否符合三角形的定义。</p>
<pre><code>public class Solution {
    /*
     * @param S: A list of integers
     * @return: An integer
     */
    public int triangleCount(int[] S) {
        // write your code here
        int index = 0;
        for(int i=0; i&lt;S.length-2; i++){
            for(int j=i+1; j&lt;S.length-1;j++){
                for(int k=j+1;k&lt;S.length;k++){
                    if(isTriangle(S[i],S[j],S[k]))
                        index++;
                }
            }
        }
        return index;
    }

    public static boolean isTriangle(int a, int b, int c){
        if(a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a)
            return true;
        else
            return false;
    }
}
</code></pre><p>解法二：<br>三角形两边之和大于第三边，先将数组排序，然后定位最长边与最短边，然后寻找第三条边的数量，第三条边满足：</p>
<p>最长边 &gt;= 第三条边 &gt; 最长边 - 最短边<br>可以利用二分查找寻找最短的第三条边的下标，然后和最长边下标之差就是第三条边的数量<br>最后继续定位定位最长边与最短边</p>
<pre><code>class Solution {
public:
    /*
     * @param : A list of integers
     * @return: An integer
     */
    int triangleCount(vector&lt;int&gt; S) {
        // write your code here
        int size = S.size();
        if (size &lt;= 0) {
            return 0;
        }

        int result = 0;
        sort(S.begin(), S.end());
        for (int i = 0; i &lt; size - 1; i++) {
            for (int j = i + 1; j &lt; size; j++) {
                int third = S[j] - S[i];
                int low = i + 1, high = j;
                while (low &lt; high) {
                    int mid = low + (high - low) / 2;
                    if (S[mid] &gt; third) {
                        high = mid;
                    }
                    else {
                        low = mid + 1;
                    }
                }
                result += (j - low);
            }
        }
        return result;
    }
};
</code></pre><h2 id="计算最大值"><a href="#计算最大值" class="headerlink" title="计算最大值"></a>计算最大值</h2><p>给一个字符串类型的数字, 写一个方法去找到最大值, 你可以在任意两个数字间加 + 或 *</p>
<p>您在真实的面试中是否遇到过这个题？ Yes</p>
<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><p>给出 str = 01231, 返回 10 ((((0 + 1) + 2) <em> 3) + 1) = 10 我们得到了最大值 10<br>给出 str = 891, 返回 73 因为 8 </em> 9 <em> 1 = 72 和 8 </em> 9 + 1 = 73, 所以73是最大值</p>
<pre><code>public class Solution {
    /*
     * @param : the given string
     * @return: the maximum value
     */
    public int calcMaxValue(String str) {
        // write your code here
        if(str.equals(&quot;&quot;))
            return 0;
        String[] array = str.split(&quot;&quot;);
        int max_result = Integer.parseInt(array[0]);
        for(int i=0;i&lt;array.length-1;i++){
            int add = max_result+Integer.parseInt(array[i+1]);
            int multify = max_result*Integer.parseInt(array[i+1]);
            if(add&gt;=max_result&amp;&amp;add&gt;=multify)
                max_result = add;
            if(multify&gt;=max_result&amp;&amp;multify&gt;add)
                max_result = multify;
        }
        return max_result;
    }
};
</code></pre><h2 id="重复子串"><a href="#重复子串" class="headerlink" title="重复子串"></a>重复子串</h2><p>写一个方法, 给一个由 N 个字符构成的字符串 A和一个由 M 个字符构成的字符串 B, 返回 A 必须重复的次数，使得 B 是重复字符串的子串.如果 B 不可能为重复字符串的子串, 则返回 -1.</p>
<p> 注意事项</p>
<p>Assume that 0 &lt;= N &lt;= 1000, 1 &lt;= M &lt;= 1000</p>
<p>您在真实的面试中是否遇到过这个题？ Yes</p>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><p>给出 A = abcd, B = cdabcdab<br>你的方法需要返回 3, 因为在重复字符串 A 3次之后我们得到了字串 abcdabcdabcd. 字符串B是这个字符串的一个子串.</p>
<h3 id="算法详解-1"><a href="#算法详解-1" class="headerlink" title="算法详解"></a>算法详解</h3><p>先把B中间包含A的部分全部去除，看两端剩下几个字符串，如果大于两个则return -1，若是两个或一个，则再判断这两个或一个字串是否能被包含在A中。</p>
<pre><code>import java.util.LinkedList;
import java.util.List;

public class Solution {
    /*
     * @param : string A to be repeated
     * @param : string B
     * @return: the minimum number of times A has to be repeated
     */
    public static int repeatedString(String A, String B) {
        // write your code here
        if(A.length()==0)
            return -1;
        if(A.length()&gt;=B.length())
            if(A.contains(B))
                return 1;
        String[] b = B.split(A);
        int index = -1;
        List&lt;String&gt; list = new LinkedList&lt;&gt;();
        for(int i=0;i&lt;b.length;i++) {
            if (!b[i].equals(&quot;&quot;))
                list.add(b[i]);
        }
        if(A.length()&lt;B.length()){
            if(list.size()&gt;2)
                return -1;
            else {
                if (list.size() == 1)
                    if (B.substring(0, 4).equals(A) || B.substring(B.length() - 4, B.length()).equals(A)) {
                        if(!B.substring(0,4).equals(A)){
                            if(A.substring(A.length()-list.get(0).length(),A.length()).equals(list.get(0)))
                                index = 1 + (B.length() - list.get(0).length()) / A.length();
                        }
                        if(!B.substring(B.length() - 4, B.length()).equals(A)){
                            if(A.substring(0, list.get(0).length()).equals(list.get(0)))
                                index = 1 + (B.length() - list.get(0).length()) / A.length();
                        }
                    }
                if (list.size() == 2)
                    if (!B.substring(0, 4).equals(A) &amp;&amp; !B.substring(B.length() - 4, B.length()).equals(A)) {
                        if(A.substring(A.length()-list.get(0).length(),A.length()).equals(list.get(0))&amp;&amp;A.substring(0, list.get(1).length()).equals(list.get(1)))
                            index = 2 + (B.length() - list.get(0).length() - list.get(1).length()) / A.length();
                    }
                if(list.size() == 0)
                    index = B.length()/A.length();
            }
        }
        return index;
    }
}
</code></pre><h2 id="二进制时间"><a href="#二进制时间" class="headerlink" title="二进制时间"></a>二进制时间</h2><p>给了一个二进制显示时间的手表和一个非负整数 n, n 代表在给定时间表上 1 的数量, 返回所有可能的时间</p>
<p> 注意事项</p>
<p>输出的顺序没有要求.<br>小时不能包含前导零, 比如 “01:00” 是不允许的, 应该为 “1:00”.<br>分钟必须由两位数组成, 可能包含前导零, 比如 “10:2” 是无效的, 应该为 “10:02”.</p>
<p>您在真实的面试中是否遇到过这个题？ Yes</p>
<h3 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h3><p>给出 n = 1<br>返回 [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]</p>
<h3 id="算法详解-2"><a href="#算法详解-2" class="headerlink" title="算法详解"></a>算法详解</h3><p>这是一道非常有意思的题目，当然给出一个数，分别把这个数分到时和分里再细分，形成组合。这里给出两个附带的静态函数，具体代码实现很容易懂：</p>
<pre><code>import java.util.LinkedList;
import java.util.List;

public class Solution {
    /*
     * @param : the number of &quot;1&quot;s on a given timetable
     * @return: all possible time
     */
    public static List&lt;String&gt; binaryTime(int num) {
        // Write your code here
        List&lt;String&gt; list = new LinkedList&lt;&gt;();
        for(int i=0;i&lt;=num;i++){
            List&lt;String&gt; list1 = binarylist(i, true);
            List&lt;String&gt; list2 = binarylist(num-i, false);
            for(String _list1 : list1){
                for(String _list2 : list2){
                    list.add(_list1+&quot;:&quot;+_list2);
                }
            }
        }
        return list;
    }

    public static List&lt;String&gt; binarylist(int _num, boolean index) {
        List&lt;String&gt; list = new LinkedList&lt;&gt;();
        if(index == false)
            for(int k=0;k&lt;60;k++){
                if(_num==binaryOneNum(k)&amp;&amp;k&lt;10)
                    list.add(&quot;0&quot;+k);
                if(_num==binaryOneNum(k)&amp;&amp;k&gt;=10)
                    list.add(String.valueOf(k));
            }
        else
            for(int j=0;j&lt;12;j++){
                if(_num==binaryOneNum(j))
                    list.add(String.valueOf(j));
            }
        return list;
    }

    public static int binaryOneNum(int timeNum) {
        int num = 0;
        while (timeNum != 0) {
            if (timeNum % 2 == 1)
                num = num + 1;
             timeNum = timeNum/2;
        }
        return num;
    }
};
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LintCode/">LintCode</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/26/Java并发之ThreadLocal/" class="article-date">
      <time datetime="2017-10-26T12:00:00.000Z" itemprop="datePublished">2017-10-26</time>
</a>

 
    <a href="/2017/10/26/Java并发之ThreadLocal/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/10/26/Java并发之ThreadLocal/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/26/Java并发之ThreadLocal/">Java并发之ThreadLocal</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2017/10/26/Java并发之ThreadLocal/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java并发之Lock" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/24/Java并发之Lock/" class="article-date">
      <time datetime="2017-10-24T12:00:00.000Z" itemprop="datePublished">2017-10-24</time>
</a>

 
    <a href="/2017/10/24/Java并发之Lock/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/10/24/Java并发之Lock/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/24/Java并发之Lock/">Java并发之Lock</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="Lock与Synchronized区别"><a href="#Lock与Synchronized区别" class="headerlink" title="Lock与Synchronized区别"></a>Lock与Synchronized区别</h3><ul>
<li>Lock非Java内置特性，而Synchronized是Java语言的关键字，因此是内置特性。Lock是一个接口，通过这个接口可以实现同步访问。</li>
<li>Synchronized不需要手动释放锁，当Synchronized方法或代码块执行完成后，系统会自动让线程释放对锁的占用；Lock需要用户手动释放锁，如果没有释放锁，会导致死锁现象。</li>
</ul>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2017/10/24/Java并发之Lock/#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Django图片相关处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/20/Django图片相关处理/" class="article-date">
      <time datetime="2017-10-20T02:14:00.000Z" itemprop="datePublished">2017-10-20</time>
</a>

 
    <a href="/2017/10/20/Django图片相关处理/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/10/20/Django图片相关处理/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/20/Django图片相关处理/">Django图片相关处理方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="前台访问后台图片"><a href="#前台访问后台图片" class="headerlink" title="前台访问后台图片"></a>前台访问后台图片</h3><p>对于ImageField类型的字段，需要进行特殊处理，相关处理配置如下所示：</p>
<p>1、setting中配置MEDIA_URL和MEDIA_ROOT</p>
<pre><code>MEDIA_URL=&quot;media&quot;
#配置图片文件夹路径
MEDIA_ROOT=(
        os.path.join(BASE_DIR, &apos;&apos;media)
    )
</code></pre><p>2、如果使用加载，需要在setting的TEMPLATES中加上下面</p>
<pre><code>&apos;django.template.context_processors.madia&apos;
</code></pre><p>3、设置url</p>
<pre><code>from django.views.static improt serve
from project.setting import MEDIA_ROOT
url(r&apos;^media/(?P&lt;path&gt;.*)&apos;, serve,{&apos;document_root&apos;:settings.MEDIA_ROOT}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Spring基于注解的配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/19/Spring基于注解的配置/" class="article-date">
      <time datetime="2017-10-19T02:14:00.000Z" itemprop="datePublished">2017-10-19</time>
</a>

 
    <a href="/2017/10/19/Spring基于注解的配置/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/10/19/Spring基于注解的配置/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/19/Spring基于注解的配置/">Spring基于注解的配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation(注解)"></a>Annotation(注解)</h2><h3 id="标注Spring-Bean的Annotation"><a href="#标注Spring-Bean的Annotation" class="headerlink" title="标注Spring Bean的Annotation"></a>标注Spring Bean的Annotation</h3><ul>
<li>@Component：标注一个普通的Spring Bean类</li>
<li>@Service：标注一个控制器组件</li>
<li>@Controller：标注一个业务逻辑组件类</li>
<li>@Repository：标注一个DAO组件类</li>
</ul>
<p>下面为@Component的注解</p>
<pre><code>package annotation;

import org.springframework.stereotype.Component;

@Component
public class UserObject {

    public void getUser(){
        System.out.println(&quot;component  getUser...&quot;);
    }
}
</code></pre><p>其在XML中配置方式很简单，只需加上下面</p>
<pre><code>&lt;context:component-scan base-package=&quot;package(包路径)&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>可以添加<context:include-filter>和<context:exclude-filter>子元素更详细的指定Annotation标注。使用时需要添加type属性和expression.</context:exclude-filter></context:include-filter></p>
<p>其中type可以指定下面四种过滤器</p>
<ul>
<li><p>annotation: 需要指定一个注解名，如下org.springframework.stereotype.Repository，过滤DAO注解</p>
<p>  <context:component-scan base-package="annotation" use-default-filters="false"></context:component-scan></p>
<pre><code>&lt;!--&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;&gt;&lt;/context:include-filter&gt;
</code></pre><p>  </p>
</li>
<li><p>regex：正则过滤器 ，指定正则表达式</p>
</li>
<li>assignable：类名过滤器，指定java类</li>
<li><p>aspextJ:AspextJ过滤器</p>
<p>其中annotaion和assignable最常用</p>
<h3 id="Bean作用域的注解（annotation）"><a href="#Bean作用域的注解（annotation）" class="headerlink" title="Bean作用域的注解（annotation）"></a>Bean作用域的注解（annotation）</h3><p>没有指定Bean的Scope默认为singleton</p>
<p>  @Scope(“prototype”)<br>  //为Bean实例指定person名<br>  @Component(“person”)<br>  public class Person(){…}</p>
</li>
</ul>
<h3 id="Resource配置Bean依赖"><a href="#Resource配置Bean依赖" class="headerlink" title="@Resource配置Bean依赖"></a>@Resource配置Bean依赖</h3><p>一般XML的依赖配置：</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;autowire.Person&quot; p:name=&quot;huihui&quot; p:address-ref=&quot;address2&quot; &gt;&lt;/bean&gt;
</code></pre><p>注解的依赖配置        </p>
<pre><code>@Component
public Class Person{
    private String name;
    private Address address;
    public void setName(String name){
        this.name = name;
    }
    @resource(name=&quot;address&quot;)
    public void setAddress(Address address){
        this.address = address;
    }
    public void toString(){...}
}
</code></pre><p>将指定容器中的Bean作为参数传入，一般setter在XML方法是必须的，但是在注解中，@Resource可以修饰Field，可以省略name属性。在使用@Resource修饰Field时，Spring会直接使用java ee的Field注入。可以不使用setter方法。<br>@Resource修饰setter方法，省略name属性，则name属性是setter方法去掉前面set字串，首字母小写得到的字串。</p>
<p>@PostConstruct，@PreDestroy定制生命周期行为<br>init-method（@PostConstruct）在Bean依赖关系注入完成后回调该方法，destroy-method（@PreDestroy）在销毁Bean之前回调该方法。</p>
<pre><code>@Component
public class Person{
    private String name;
    private Car car;
    public void setName(String name){
        this.name = name;
    }
    @Resource
    public void setCar(Car car){
        this.car = car
    }
    @PostConstruct
    public void init(){...}
    @PreDestriy
    public void destroy(){...}
    public void toString(){...}
}
</code></pre><h3 id="DependsOn-Lazy"><a href="#DependsOn-Lazy" class="headerlink" title="@DependsOn,@Lazy"></a>@DependsOn,@Lazy</h3><p>@Depends（depends-on）用于强制初始化其他Bean，@Lazy(lazy-init)用于指定该Bean是否取消预初始化.</p>
<pre><code>@Lazy(true)
@DependsOn({&apos;car&apos;, &apos;address&apos;})
@Conponent
public class Person{...}
</code></pre><p>上面代码使用@DependsOn修饰Person类，强制初始化car和address两个Bean,使用@Lazy实现懒初始化。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>实现自动装配，标注setter方法，普通方法，Field和构造器，个人倾向显式指定依赖。<br>@QUALIfier根据Bean标识zhiding自动装配。</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>Spring提供了注解@Value，用于在程序中获取properties配置文件属性值。例如：</p>
<ol>
<li><p>applicationContext.xml中指定配置文件。</p>
 <context:property-placeholder location="classpath:xxx.properties" ignore-unresolvable="true">

<ol>
<li><p>Spring bean中使用@Value注解获取指定参数。</p>
<p>// xxx.properties配置项：<br>// server.ip=192.168.1.1<br>// server.port=8080</p>
<p>@Value(“${server.ip}”)<br>private String ip;</p>
<p>@Value(“${server.port}”)<br>private int port;</p>
</li>
</ol>
</context:property-placeholder></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Django前端页面相关处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/19/Django前端页面相关处理/" class="article-date">
      <time datetime="2017-10-19T02:14:00.000Z" itemprop="datePublished">2017-10-19</time>
</a>

 
    <a href="/2017/10/19/Django前端页面相关处理/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2017/10/19/Django前端页面相关处理/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/19/Django前端页面相关处理/">Django Html相关配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="静态文件加载"><a href="#静态文件加载" class="headerlink" title="静态文件加载"></a>静态文件加载</h2><p>html文件头要加上下面代码，意思要预加载配置文件中的staticfiles文件</p>
<pre><code>{% load staticfiles %}
</code></pre><h3 id="css，js，img文件配置"><a href="#css，js，img文件配置" class="headerlink" title="css，js，img文件配置"></a>css，js，img文件配置</h3><p>其中，static为配置文件目录</p>
<pre><code>&lt;script scr={% static 'js/example.js' %}&gt;&lt;/script&gt;
&lt;link rel=&quot;staticsheet&quot; type=&quot;text/css&quot; href={%static 'css/example.css'%}&gt;
&lt;img src={% static 'images/example.jpg' %} /&gt;
</code></pre><h3 id="url配置"><a href="#url配置" class="headerlink" title="url配置"></a>url配置</h3><pre><code>&lt;a href={% url 'login' %}&gt; 
&lt;a href={% url 'register' %}&gt;
action = /login/
action = /register/
</code></pre><h2 id="网站模板配置"><a href="#网站模板配置" class="headerlink" title="网站模板配置"></a>网站模板配置</h2><p>为了节省代码，导航，底部，访问统计等地方需要使用共同的html。<br>使用base.html来包含通用的文件</p>
<pre><code>&lt;!DOCTYPE html5&gt;
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;&lt;% block title %&gt;标题&lt;% endtitle %&gt;&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;% include &apos;nav.html&apos; %&gt;
        &lt;% block main %&gt;
        &lt;main-section /&gt;
        &lt;% endblock %&gt;
        &lt;% include &apos;foot.html&apos; %&gt;    
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>其中block为使继承的模板可以随意重写该部分，include作用是加载其他html文件。<br>我们可以通过继承或者说是扩展<br>extends原来的base.html文件，这样可以重写减少工作量</p>
<pre><code>&lt;% extends &apos;base.html&apos; %&gt;
&lt;% block title %&gt;new title&lt;% endblock %&gt;

&lt;% block main %&gt;new main content&lt;% endblock %&gt;    
</code></pre><p>一般模板放在app下的templates中，django会自动查找，我们一般使用类里加载html文件的形式.</p>
<pre><code>return render(request, &apos;index.html&apos;)
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机/">计算机</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 huiHui
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>


    

    
        <script id="dsq-count-scr" src="//.disqus.com/count.js" async></script>
        <script>
            if ($(".left-col").is(":visible")) {
                var $disqusCount = $(".disqus-comment-count");
                $disqusCount.bind("DOMNodeInserted", function(e) {
                    var num = $(this).text().replace(/[^0-9]/ig,"");
                    if (num > 0) {
                        $(this).siblings(".count-comment").text(num);
                    }
                    $(this).remove();
                })
            } else {
                $(".disqus-comment-count").remove();
            }
        </script>
     




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>